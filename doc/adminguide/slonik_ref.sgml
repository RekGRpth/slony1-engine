<ARTICLE id="slonikcommands">
<title>Slonik Command Summary</title>
<sect1 id="slonikintro">
<title>Slonik Command Summary</title>
<sect2><title/Introduction/

<para>
	<application>Slonik</application> is a command line utility designed
	specifically to setup and modify configurations of the
	<productname>Slony-I</productname> replication system.
</para>

<sect2 id="outline">
<title>General outline</title>

<para>
	The <application>slonik</application> commandline utility is supposed to be
	used embedded into shell scripts and reads commands from files
	or stdin (via here documents for example). Nearly all of the
	<emphasis>real</emphasis> configuration work is done by
	calling stored procedures after loading the
	<productname>Slony-I</productname> support base into a database.  You may
	find documentation for those procedures in the <ulink
	url="schemadoc"><productname>Slony-I</productname> Schema
	Documentation</ulink>, as well as in comments associated with
	them in the database.
</para>

      <para>
	<Application>Slonik</Application> was created because:
      <itemizedlist>

	<listitem><para>The stored procedures have special
	requirements as to on which particular node in the replication
	system they are called,</para></listitem>

	<listitem><para>The lack of named parameters for stored
	procedures makes it rather difficult to do this from the
	<application>psql</application> prompt, and</para></listitem>

	<listitem><para><application>psql</application>lacks the ability to
	maintain multiple connections with open transactions.</para></listitem>
      </itemizedlist>
      </para>
<para>
	
</para>
<sect3><title>Commands</title>
<para>
	The slonik command language is format free. Commands begin with
	keywords and are terminated with a semicolon. Most commands have
	a list of parameters, some of which have default values and are
	therefore optional. The parameters of commands are enclosed in
	parentheses. Each option consists of one or more keywords, followed
	by an equal sign, followed by a value. Multiple options inside the
	parentheses are separated by commas. All keywords are case
	insensitive.  The language should remind the reader of SQL.
</para>
<para>
	Option values may be:
	<itemizedlist>
		<listitem><para>integer values</para></listitem>
		<listitem><para>string literals enclosed in single quotes</para></listitem>
		<listitem><para>boolean values {TRUE|ON|YES} or {FALSE|OFF|NO}</para></listitem>
		<listitem><para>keywords for special cases</para></listitem>
	</itemizedlist>
</para>
<sect3><title>Comments</title>
<para>
	Comments begin at a hash sign (#) and extend to the end of the line.
</para>
<sect3><title>Command groups</title>
<para>
	Commands can be combined into groups of commands with optional
	<command>on error</command> and <command>on success</command> conditionals.
	The syntax for this is:
<programlisting>
try {
   commands;
} 
[on error { commands; }
[on success { commands; }
</programlisting>
<para>	Those commands are grouped together into one transaction per
	participating node.
</para>

<!-- ************************************************************ -->

<reference id="hdrcmds"> 
<title>Slonik Header Commands</title>
<partintro>
<para>
	The following commands must appear as a <quote/preamble/ at the very
	top of every <application/slonik/ command script. They do not cause any
	direct action on any of the nodes in the replication system,
	but affect the execution of the entire script.
</para>
</partintro>
<!-- **************************************** -->

<refentry id ="clustername"><refmeta><refentrytitle>CLUSTER NAME</refentrytitle> </refmeta>

<refnamediv><refname>CLUSTER NAME</refname>

<refpurpose> preamble - identifying <productname/Slony-I/ cluster </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>CLUSTER NAME = </command>
<arg><replaceable class="parameter"> 'clustername';</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
	Must be the very first command in every <application/slonik/ script. Defines
	the namespace in which all <productname/Slony-I/ specific functions,
	procedures, tables and sequences are defined. The namespace
	name is built by prefixing the given string literal with an
	underscore. This namespace will be identical in all databases
	that participate in the same replication group. 
</para>

<para>
                  No user objects are supposed to live in this
                  namespace and the namespace is not allowed to exist
                  prior to adding a database to the replication
                  system.  Thus, if you add a new node using <command>
                  pg_dump -s </command> on a database that is already in
                  the cluster of replicated databases, you will need
                  to drop the namespace via the SQL command <command> DROP
                  SCHEMA _testcluster CASCADE; </command>.
</para>
</refsect1>
<refsect1><title>Example</title>
<programlisting>
	CLUSTER NAME = 'testcluster';
</programlisting>
</refsect1>
</refentry>


<!-- **************************************** -->

<refentry id ="admconninfo"><refmeta><refentrytitle>ADMIN CONNINFO</refentrytitle> </refmeta>

<refnamediv><refname>ADMIN CONNINFO</refname>

<refpurpose> preamble - identifying <productname/PostgreSQL/ database </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>NODE ival ADMIN CONNINFO = 'DSN';</command>
<arg><replaceable class="parameter"> ival;</replaceable></arg>
<arg><replaceable class="parameter"> 'conninfo'</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
	Describes how the <application/slonik/ utility can reach a nodes database in
	the cluster from where it is run (likely the DBA's
	workstation). The conninfo string is the string agrument given
	to the <function/PQconnectdb()/ libpq function. The user used to connect
	must be the special replication superuser, as some of the
	actions performed later may include operations that are
	strictly reserved for database superusers by PostgreSQL.
</para>

<para>
	The <application/slonik/ utility will not try to connect to the databases
	unless some subsequent command requires the connection.
 </Para>

<para>
	Note: As mentioned in the original documents, <productname/Slony-I/ is designed as an
	enterprise replication system for data centers. It has been
	assumed throughout the entire development that the database
	servers and administrative workstations involved in
	replication and/or setup and configuration activities can use
	simple authentication schemes like <quote>trust</quote>.
	Alternatively, libpq can read passwords from <filename>
	.pgpass </filename>.
</para>
<para>
	Note: If you need to change the DSN information for a node, as
	would happen if the IP address for a host were to change, you
	may submit the new information using this command, and that
	configuration will be propagated.  Existing <application/>
	slon </application>
	processes will need to be restarted in order to become aware
	of the configuration change.
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
	NODE 1 ADMIN CONNINFO = 'dbname=testdb host=server1 user=slony';
</Programlisting>
</Refsect1>
</Refentry>
 

<!-- **************************************** -->

<refentry id ="stmtecho"><refmeta><refentrytitle>ECHO</refentrytitle> </refmeta>

<refnamediv><refname>ECHO</refname>

<refpurpose> Generic debugging tool </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>echo </command>
<arg><replaceable class="parameter"> 'string'</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
	Prints the string literal on standard output.
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
	ECHO 'Node 1 initialized successfully';
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->

<refentry id ="stmtexit"><refmeta><refentrytitle>EXIT</refentrytitle> </refmeta>

<refnamediv><refname>EXIT</refname>

<refpurpose> Generic debugging tool </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>exit</command>
<arg><replaceable class="parameter"> [-]ival</replaceable></arg>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>
<para>
	Terminates script execution immediately, rolling back every
	open transaction on all database connections. The
	<application/slonik/ utility
	will return the given value as its program termination code.
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
	EXIT 0;
</Programlisting>
</Refsect1>
</Refentry>
</reference>
<!-- ************************************************************ -->


<!-- **************************************** -->
<reference id="cmds">
	<title>Configuration and Action commmands</title>
	<refentry id ="stmtinitcluster">
		<refmeta>
			<refentrytitle>INIT CLUSTER</refentrytitle>
		</refmeta>

		<refnamediv>
			<refname>INIT CLUSTER</refname>

			<refpurpose>Initialize <productname>Slony-I</productname> cluster</refpurpose>
			<refsynopsisdiv>
				<cmdsynopsis>
					<command>INIT CLUSTER</command> 
					<arg>ID = <replaceable class="parameter">integer</replaceable></arg>
					<arg>COMMENT = <replaceable class="parameter">'string'</replaceable></arg>
				</cmdsynopsis>
			</refsynopsisdiv>
			<refsect1>
				<title>Description</title>
				<para> Initialize the first node in a new <productname/Slony-I/
				replication cluster.  The initialization process consists of creating
				the cluster namespace, loading all the base tables, functions,
				procedures and initializing the node.

				<variablelist>
					<varlistentry><term><literal>ID</literal></term>
						<listitem><para>The unique, numeric ID number of the node.</para></listitem>
					</varlistentry>

 					<varlistentry><term><literal>COMMENT = 'comment text'</literal></term>
						<listitem><para> A descriptive text added to the node entry in the table sl_node.</para></listitem>
					</varlistentry>
				</variablelist>

				</para>

				<para> For this process to work, the SQL scripts of the
				<productname>Slony-I</productname> system must be installed on the DBA workstation
				(the computer currently executing the <application>slonik</application> utility),
				while on the system where the node database is running the shared
				objects of the <productname>Slony-I</productname> system must be installed in the
				PostgreSQL library directory. Also the procedural language PL/pgSQL is
				assumed to already be installed in the target database.</para>
			</Refsect1>
			<Refsect1>
				<Title>Example</Title>
				<Programlisting>
					INIT CLUSTER (
						ID = 1,
						COMMENT = 'Node 1'
					);
				</Programlisting>
			</Refsect1>
	</Refentry>

<!-- **************************************** -->

<refentry id ="stmtstorenode"><refmeta><refentrytitle>STORE NODE</refentrytitle> </refmeta>

<refnamediv><refname>STORE NODE</refname>


<refpurpose> Initialize <productname/Slony-I/ node </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>STORE NODE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> Initialize a new node and add it to the configuration of an
existing cluster.</para>

<para> The initialization process consists of creating the cluster
namespace in the new node (the database itself must already exist),
loading all the base tables, functions, procedures and initializing
the node. The existing configuration of the rest of the cluster is
copied from the <quote>event node</quote>.

<variablelist>
 <varlistentry><term><literal>ID  = ival</literal></term>
  <listitem><para> The unique, numeric ID number of the new node.</para></listitem>
 </varlistentry>

 <varlistentry><term><literal> COMMENT = 'description' </literal></term>
  <listitem><para> A descriptive text added to the node entry in the table sl_node.</para></listitem>
 </varlistentry>

 <varlistentry><term><literal> SPOOLNODE = boolean </literal></term>

  <listitem><para>Specifies that the new node is a virtual spool node
  for file archiving of replication log. If true <application/slonik/
  will not attempt to initialize a database with the replication
  schema.</para></listitem>

 </varlistentry>
 <varlistentry><term><literal> EVENT NODE = ival </literal></term>

  <listitem><para> The ID of the node used to create the configuration
  event that tells all existing nodes about the new node. Default
  value is 1.</para></listitem>
 </varlistentry>
</variablelist>
</para>

</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  STORE NODE ( ID = 2, COMMENT = 'Node 2');
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->
<refentry id ="stmtdropnode"><refmeta><refentrytitle>DROP NODE</refentrytitle> </refmeta>

<refnamediv><refname>DROP NODE</refname>

<refpurpose> Decommission <productname/Slony-I/ node </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>DROP NODE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Drop a node. This command removes the specified node entirely from
	the replication systems configuration. If the replication daemon
	is still running on that node (and processing events), it will
	attempt to uninstall the replication system and terminate itself.

<variablelist>
 <varlistentry><term><literal> ID  = ival </literal></term>
  <listitem><para> Node ID of the node to remove.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> EVENT NODE = ival </literal></term>
  <listitem><para> Node ID of the node to generate the event.</para></listitem>
 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  DROP NODE ( ID = 2 );
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->
<refentry id ="stmtuninstallnode"><refmeta><refentrytitle>UNINSTALL NODE</refentrytitle> </refmeta>

<refnamediv><refname>UNINSTALL NODE</refname>

<refpurpose> Decommission <productname/Slony-I/ node </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>UNINSTALL NODE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Restores all tables to the unlocked state, with all original
	user triggers, constraints and rules, eventually added <productname/Slony-I/
	specific serial key columns dropped and the <productname/Slony-I/ schema
	dropped. The node becomes a standalone database. The data is
	left untouched.

<variablelist>
 <varlistentry><term><literal> ID  = ival </literal></term>
  <listitem><para> Node ID of the node to uninstall.</para></listitem>
 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  UNINSTALL NODE ( ID = 2 );
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->

<refentry id ="stmtrestartnode"><refmeta><refentrytitle>RESTART NODE</refentrytitle> </refmeta>

<refnamediv><refname>RESTART NODE</refname>

<refpurpose> Restart <productname/Slony-I/ node </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>RESTART NODE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> Causes an eventually running replication daemon on the
specified node to shutdown and restart itself. Theoretically this
command should be obsolete. In practice, TCP timeouts can delay
critical configuration changes to actually happen in the case where a
former forwarding node failed and needs to be bypassed by subscribers.

<variablelist>
 <varlistentry><term><literal> ID  = ival </literal></term>
  <listitem><para> Node ID of the node to restart.</para></listitem>
 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  RESTART NODE ( ID = 2 );
</Programlisting>
</Refsect1>
</Refentry>
 

<!-- **************************************** -->

<refentry id ="stmtstorepath"><refmeta><refentrytitle>STORE PATH</refentrytitle> </refmeta>

<refnamediv><refname>STORE PATH</refname>

<refpurpose> Configure <productname/Slony-I/ node </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>STORE PATH (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> Configures how the replication daemon of one node connects to
the database of another node. If the replication system is supposed to
use a special backbone network segment, this is the place to user the
special IP addresses or hostnames. An existing configuration can be
overwritten.</para>

<para>	The conninfo string must contain all information to connect to the
	database as the replication superuser. The names <quote/server/ or
	<quote/client/ have nothing to do with the particular role of a node
	within the cluster configuration. It should be simply viewed as
	<quote/the server/ has the message or data that <quote/the client
	is supposed to get./  For a simple 2 node setup, paths into both
	directions must be configured.
</para>
<para>
	It does not do any harm to configure path information from every
	node to every other node (full cross product). The connections
	are not established unless they are required to actually transfer
	events or confirmations because of <emphasis/listen/ entries or data
	because of <emphasis/subscriptions/.

<variablelist>
 <varlistentry><term><literal> SERVER  = ival </literal></term>
  <listitem><para> Node ID of the database to connect to.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> CLIENT  = ival </literal></term>
  <listitem><para> Node ID of the replication daemon connecting.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> CONNINFO  = string </literal></term>
  <listitem><para> <function/PQconnectdb()/ argument to establish the connection.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> CONNRETRY  = ival </literal></term>
  <listitem><para> Number of seconds to wait before another attempt to
  connect is made in case the server is unavailable. Default is 10.
  </para></listitem>
 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  STORE PATH ( SERVER = 1, CLIENT = 2, 
               CONNINFO = 'dbname=testdb host=server1 user=slony'
             );
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtdroppath"><refmeta><refentrytitle>DROP PATH</refentrytitle> </refmeta>

<refnamediv><refname>DROP PATH</refname>

<refpurpose> Configure <productname/Slony-I/ node </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>DROP PATH (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> 	Remove the connection information between <quote/server/ and
	<quote/client/.



<variablelist>
 <varlistentry><term><literal> SERVER  = ival </literal></term>
  <listitem><para> Node ID of the database to connect to.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> CLIENT  = ival </literal></term>
  <listitem><para> Node ID of the replication daemon connecting.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> EVENT NODE = ival </literal></term>

  <listitem><para> The ID of the node used to create the configuration
  event that tells all existing nodes about dropping the path.
  Defaults to the <quote/client/, if omitted.
 </para>
 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  DROP PATH ( SERVER = 1, CLIENT = 2 );
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtstorelisten"><refmeta><refentrytitle>STORE LISTEN</refentrytitle> </refmeta>

<refnamediv><refname>STORE LISTEN</refname>

<refpurpose> Configure <productname/Slony-I/ node </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>STORE LISTEN (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> A <quote/listen/ entry causes a node (receiver) to query an
event provider for events that originate from a specific node, as well
as confirmations from every existing node. It requires a <quote/path/
to exist so that the receiver (as client) can connect to the provider
(as server).

<para>
	Every node in the system must listen for events from every
	other node in the system. As a general rule of thumb, a
	subscriber (see <link linkend="stmtsubscribeset">SUBSCRIBE
	SET</link>) should listen for events of the set's origin on
	the same provider, where it receives the data from. In turn,
	the origin of the data set should listen for events from the
	origin in the opposite direction. A node can listen for events
	from one and the same origin on different providers at the
	same time. However, to process <command/SYNC/ events from that
	origin, all data providers must have the same or higher sync
	status, so this will not result in any faster replication
	behaviour.
</para>

<variablelist>
 <varlistentry><term><literal> ORIGIN  = ival </literal></term>
  <listitem><para> Node ID of the event origin the receiver is listening for.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> PROVIDER  = ival </literal></term>
  <listitem><para> Node ID of the node from which the receiver gets events that come from the origin.   If not specified, default is the origin.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> RECEIVER = ival </literal></term>

  <listitem><para> The ID of the node receiving the events.</para></listitem>
 </varlistentry>
</variablelist>

<para> For more details, see the section on <link
linkend="listenpaths"> Slony-I Listen Paths. </link>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  STORE LISTEN ( ORIGIN = 1, RECEIVER = 2, PROVIDER = 3 );
</Programlisting>
</Refsect1>
</Refentry>
 

<!-- **************************************** -->

<refentry id ="stmtdroplisten"><refmeta><refentrytitle>DROP LISTEN</refentrytitle> </refmeta>

<refnamediv><refname>DROP LISTEN</refname>

<refpurpose> Configure <productname/Slony-I/ node </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>DROP LISTEN (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> Remove a <quote/listen/ configuration entry. </para>

<variablelist>
 <varlistentry><term><literal> ORIGIN  = ival </literal></term>
  <listitem><para> Node ID of the event origin the receiver is listening for.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> PROVIDER  = ival </literal></term>
  <listitem><para> Node ID of the node from which the receiver gets events that come from the origin.   If not specified, default is the origin.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> RECEIVER = ival </literal></term>

  <listitem><para> The ID of the node receiving the events.</para></listitem>
 </varlistentry>
</variablelist>

</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  DROP LISTEN ( ORIGIN = 1, RECEIVER = 2, PROVIDER = 3 );
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmttableaddkey"><refmeta><refentrytitle>TABLE ADD KEY</refentrytitle> </refmeta>

<refnamediv><refname>TABLE ADD KEY</refname>

<refpurpose> Configure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>TABLE ADD KEY (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	In the <productname/Slony-I/ replication system, every replicated table is
	required to have at least one <command/UNIQUE/ constraint
	whose columns are declared <command>NOT NULL.</command> Any
	primary key satisfies this
	requirement.
</para>
<para>
	As a last resort, this command can be used to add such an
	attribute to a table that does not have a primary key. Since
	this modification can have unwanted side effects, <emphasis>it is
	strongly recommended that users add a unique and not null
	attribute by other means.</emphasis>
</para>


<variablelist>
 <varlistentry><term><literal> NODE ID = ival </literal></term>
  <listitem><para> Node ID of the set origin where the table will be
  added as a set member. (See <link linkend="stmtsetaddtable">
  <command>SET ADD TABLE</command></link>.)</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> FULLY QUALIFIED NAME  = 'string' </literal></term>
  <listitem><para> The full name of the table consisting of the schema
  and table name as the SQL expression <command>quote_ident(nspname)
  || '.' || quote_ident(relname)</command>
   would return it.</para></listitem>
 </varlistentry>
</variablelist>

</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  TABLE ADD KEY ( NODE ID = 1, 
                  FULLY QUALIFIED NAME = 'public.history' );
</Programlisting>
</Refsect1>
</Refentry>
 

<!-- **************************************** -->

<refentry id ="stmtcreateset"><refmeta><refentrytitle>CREATE SET</refentrytitle> </refmeta>

<refnamediv><refname>CREATE SET</refname>

<refpurpose> Configure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>CREATE SET (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	In the <productname/Slony-I/ replication system, replicated tables are
	organized in sets. As a general rule of thumb, a set should
	contain all the tables of one application, that have
	relationships.  In a well designed application, this is equal
	to all the tables in one schema.
</para>
<para>
	The smallest unit one node can subscribe for replication from
	another node is a set. A set always has an origin. In
	classical replication terms, that would be the <quote/master./
	Since in <productname/Slony-I/ a node can be the <quote/master/ over one set,
	while receiving replication data in the <quote/slave/ role for
	another at the same time, this terminology may easily become
	misleading and should therefore be replaced with <quote>set
	origin</quote> and <quote>subscriber</quote>.
</para>


<variablelist>
 <varlistentry><term><literal> ID = ival </literal></term>
  <listitem><para> ID of the set to be created.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>
  <listitem><para> Initial origin node of the set.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> COMMENT = 'string' </literal></term>
  <listitem><para> A descriptive text added to the set entry.</para></listitem>
 </varlistentry>
</variablelist>

</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  CREATE SET ( ID = 1, 
               ORIGIN = 1,
               COMMENT = 'Tables for ticketing system' );
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtdropset"><refmeta><refentrytitle>DROP SET</refentrytitle> </refmeta>

<refnamediv><refname>DROP SET</refname>

<refpurpose> Configure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>DROP SET (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Drop a set of tables from the <productname/Slony-I/ configuration. This
	automatically unsubscribes all nodes from the set and restores
	the original triggers and rules on all subscribers.
</para>

<variablelist>
 <varlistentry><term><literal> ID = ival </literal></term>
  <listitem><para> ID of the set to be dropped.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>
  <listitem><para> Current origin node of the set.</para></listitem>
 </varlistentry>
</variablelist>

</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  DROP SET ( ID = 5, 
             ORIGIN = 2 );
</Programlisting>
</Refsect1>
</Refentry>
 

<!-- **************************************** -->

<refentry id ="stmtmergeset"><refmeta><refentrytitle>MERGE SET</refentrytitle> </refmeta>

<refnamediv><refname>MERGE SET</refname>

<refpurpose> Reconfigure <productname/Slony-I/ sets </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>MERGE SET (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Merge a set of tables and sequences into another one. This
	function is a workaround for the problem that it is not
	possible to add tables/sequences to already-subscribed
	sets. One may create a temporary set, add the new objects to
	that, subscribe all nodes currently subscribed to the other
	set to this new one, and then merge the two together.
</para>
<para>
	This request will fail if the two sets do not have
	<emphasis/exactly/ the same set of subscribers.  </para>

<variablelist>
 <varlistentry><term><literal> ID = ival </literal></term>
  <listitem><para> Unique ID of the set to contain the union of the two separate sets.</para></listitem>
 </varlistentry>
 <varlistentry><term><literal> ADD ID = ival </literal></term>
  <listitem><para> Unique ID of the set whose objects should be transferred.  </para>
 </varlistentry>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>
  <listitem><para> Current origin node for both sets.  </para>
 </varlistentry>
</variablelist>

</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
  MERGE SET ( ID = 2, 
              ADD ID = 9999,
              ORIGIN = 1 );
</Programlisting>
</Refsect1>
</Refentry>
 

<!-- **************************************** -->

<refentry id ="stmtsetaddtable"><refmeta><refentrytitle>SET ADD TABLE</refentrytitle> </refmeta>

<refnamediv><refname>SET ADD TABLE</refname>

<refpurpose> Configure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>SET ADD TABLE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Add an existing user table to a replication set. The set
	cannot currently be subscribed by any other node - that
	functionality is supported by the <command><link
	linkend="stmtmergeset"> MERGE SET</link> </command> command.

<variablelist>
 <varlistentry><term><literal> SET ID = ival </literal></term>
  <listitem><para> ID of the set to which the table is to be added.  </para>
 </varlistentry>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>
  <listitem><para> Origin node for the set.  A future version of <application/slonik/
		might figure out this information by itself.</para>
 </varlistentry>
 <varlistentry><term><literal> ID = ival </literal></term>

  <listitem><para> Unique ID of the table. These ID's are not only
  used to uniquely identify the individual table within the
  replication system. The numeric value of this ID also determines the
  order in which the tables are locked in a <link
  linkend="stmtlockset">LOCK SET</link> command for example. So
  these numbers should represent any applicable table hierarchy to
  make sure the <application/slonik/ command scripts do not deadlock
  at any critical moment.
 </varlistentry>
 <varlistentry><term><literal> FULLY QUALIFIED NAME = 'string' </literal></term>
  <listitem><para> The full table name as described in
		<link linkend="stmttableaddkey">TABLE ADD KEY</link>.</para>
 </varlistentry>
 <varlistentry><term><literal> KEY = { 'string' | SERIAL } </literal></term>
  <listitem><para> 
		<emphasis>(Optional)</emphasis>
		The index name that covers the unique and not null column set
		to be used as the row identifier for replication purposes. Or the
		keyword SERIAL to use the special column added with a previous
		<link linkend="stmttableaddkey">TABLE ADD KEY</link> command. Default
		is to use the table's primary key.  The index name is <emphasis> not </emphasis> 
		fully qualified; you must omit the namespace.

 </varlistentry>
 <varlistentry><term><literal> COMMENT = 'string' </literal></term>
  <listitem><para> A descriptive text added to the table entry.  </para>
 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
SET ADD TABLE (
    SET ID = 1,
    ORIGIN = 1,
    ID = 20,
    FULLY QUALIFIED NAME = 'public.tracker_ticket',
    COMMENT = 'Support ticket'
);
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtsetaddsequence"><refmeta><refentrytitle>SET ADD SEQUENCE</refentrytitle> </refmeta>

<refnamediv><refname>SET ADD SEQUENCE</refname>

<refpurpose> Configure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>SET ADD SEQUENCE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Add an existing user sequence to a replication set. The set
	cannot currently be subscribed by any other node - that
	functionality is supported by the <command><link
	linkend="stmtmergeset"> MERGE SET</link> </command> command.

<variablelist>
 <varlistentry><term><literal> SET ID = ival </literal></term>
  <listitem><para> ID of the set to which the sequence is to be added.  </para>
 </varlistentry>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>
  <listitem><para> Origin node for the set.  A future version of <application/slonik/
		might figure out this information by itself.</para>
 </varlistentry>
 <varlistentry><term><literal> ID = ival </literal></term>

  <listitem><para> Unique ID of the sequence.  <note><para> Note that this ID needs to be unique <emphasis/across sequences/ throughout the cluster; the numbering of tables is separate, so you might have a table with ID 20 and a sequence with ID 20, and they would be recognized as separate. </note>

 </varlistentry>
 <varlistentry><term><literal> FULLY QUALIFIED NAME = 'string' </literal></term>
  <listitem><para> The full sequence name as described in
		<link linkend="stmttableaddkey">TABLE ADD KEY</link>.</para>
 </varlistentry>
 <varlistentry><term><literal> COMMENT = 'string' </literal></term>
  <listitem><para> A descriptive text added to the sequence entry.  </para>
 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
SET ADD SEQUENCE (
    SET ID = 1,
    ORIGIN = 1,
    ID = 20,
    FULLY QUALIFIED NAME = 'public.tracker_ticket_id_seq',
    COMMENT = 'Support ticket ID sequence'
);
</Programlisting>
</Refsect1>
</Refentry>
 

<!-- **************************************** -->

<refentry id ="stmtsetdroptable"><refmeta><refentrytitle>SET DROP TABLE</refentrytitle> </refmeta>

<refnamediv><refname>SET DROP TABLE</refname>

<refpurpose> Configure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>SET DROP TABLE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Drop a table from a replication set.
</para>
<para>
	  Note that this action will <emphasis> not </emphasis> drop a candidate
	  primary key created using <link
	  linkend="stmttableaddkey"> <command> TABLE ADD KEY
	  </command></link>.

<variablelist>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>
  <listitem><para> Origin node for the set.  A future version of <application/slonik/
		might figure out this information by itself.</para>
 </varlistentry>
 <varlistentry><term><literal> ID = ival </literal></term>

  <listitem><para> Unique ID of the table.
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
SET DROP TABLE (
    ORIGIN = 1,
    ID = 20,
);
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->


<!-- **************************************** -->

<refentry id ="stmtsetdropsequence"><refmeta><refentrytitle>SET DROP SEQUENCE</refentrytitle> </refmeta>

<refnamediv><refname>SET DROP SEQUENCE</refname>

<refpurpose> Configure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>SET DROP SEQUENCE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Drops an existing user sequence from a replication set.
<variablelist>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>
  <listitem><para> Origin node for the set.  A future version of <application/slonik/
		might figure out this information by itself.</para>
 </varlistentry>
 <varlistentry><term><literal> ID = ival </literal></term>

  <listitem><para> Unique ID of the sequence.

 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
SET DROP SEQUENCE (
    ORIGIN = 1,
    ID = 20,
);
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->

<refentry id ="stmtsetmovetable"><refmeta><refentrytitle>SET MOVE TABLE</refentrytitle> </refmeta>

<refnamediv><refname>SET MOVE TABLE</refname>

<refpurpose> Reconfigure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>SET MOVE TABLE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Change the set a table belongs to. The current set and the new
	set must origin on the same node and subscribed by the same
	nodes.  <caution><para> Due to the way subscribing to new sets
	works make absolutely sure that the subscription of all nodes
	to the sets is completely processed before moving
	tables. Moving a table too early to a new set causes the
	subscriber to try and add the table already during the
	subscription process, which fails with a duplicate key error
	and breaks replication.</para></caution>

<variablelist>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>
  <listitem><para> Current origin of the set.  A future version of <application/slonik/
		might figure out this information by itself.</para>
 </varlistentry>
 <varlistentry><term><literal> ID = ival </literal></term>

  <listitem><para> Unique ID of the table.
 <varlistentry><term><literal> NEW SET = ival </literal></term>

  <listitem><para> Unique ID of the set to which the table should be added.
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
SET MOVE TABLE (
    ORIGIN = 1,
    ID = 20,
    NEW SET = 3
);
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtsetmovesequence"><refmeta><refentrytitle>SET MOVE SEQUENCE</refentrytitle> </refmeta>

<refnamediv><refname>SET MOVE SEQUENCE</refname>

<refpurpose> Reconfigure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>SET MOVE SEQUENCE (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	Change the set a sequence belongs to. The current set and the new set
	must originate on the same node and subscribed by the same
	nodes.

	<caution><Para> Due to the way subscribing to new sets works make
	absolutely sure that the subscription of all nodes to the sets
	is completely processed before moving sequences. Moving a sequence too
	early to a new set causes the subscriber to try and add the sequence
	already during the subscription process, which fails with a duplicate
	key error and breaks replication.</para></caution>

<variablelist>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>
  <listitem><para> Origin node for the set.  A future version of <application/slonik/
		might figure out this information by itself.</para>
 </varlistentry>
 <varlistentry><term><literal> ID = ival </literal></term>

  <listitem><para> Unique ID of the sequence.

 </varlistentry>
 <varlistentry><term><literal> NEW SET = ival </literal></term>

  <listitem><para> Unique ID of the set to which the sequence should be moved.

 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
SET MOVE SEQUENCE (
    ORIGIN = 1,
    ID = 20,
    NEW SET = 3
);
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtstoretrigger"><refmeta><refentrytitle>STORE TRIGGER</refentrytitle> </refmeta>

<refnamediv><refname>STORE TRIGGER</refname>

<refpurpose> Configure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>STORE TRIGGER (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> By default, all user defined triggers and constraints are
disabled on all subscriber nodes while a table is replicated. This
command can be used to explicitly exclude a trigger from being
disabled.

<variablelist>
 <varlistentry><term><literal> TABLE ID = ival </literal></term>
  <listitem><para> The unique, numeric ID number of the table the trigger is defined for.

 </varlistentry>
 <varlistentry><term><literal> TRIGGER NAME = 'string' </literal></term>

  <listitem><para> The name of the trigger as it appears in the
  <envar/pg_trigger/ system catalog.

 </varlistentry>
 <varlistentry><term><literal> EVENT NODE = ival </literal></term>

  <listitem><para> (Optional) The ID of the node used to create the
  configuration event
		that tells all existing nodes about the special trigger. Default
		value is 1.

 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
STORE TRIGGER (
    TABLE ID = 2,
    TRIGGER NAME = 'cache_invalidation'
);
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->

<refentry id ="stmtdroptrigger"><refmeta><refentrytitle>DROP TRIGGER</refentrytitle> </refmeta>

<refnamediv><refname>DROP TRIGGER</refname>

<refpurpose> Reconfigure <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>DROP TRIGGER (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> 	Remove the special handling for the specified trigger.

<variablelist>
 <varlistentry><term><literal> TABLE ID = ival </literal></term>
  <listitem><para> The unique, numeric ID number of the table the trigger is defined for.

 </varlistentry>
 <varlistentry><term><literal> TRIGGER NAME = 'string' </literal></term>

  <listitem><para> The name of the trigger as it appears in the
  <envar/pg_trigger/ system catalog.

 </varlistentry>
 <varlistentry><term><literal> EVENT NODE = ival </literal></term>

  <listitem><para> (Optional) The ID of the node used to create the
  configuration event
		that tells all existing nodes about the special trigger. Default
		value is 1.

 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
DROP TRIGGER (
    TABLE ID = 2,
    TRIGGER NAME = 'cache_invalidation'
);
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->
<refentry id ="stmtsubscribeset"><refmeta><refentrytitle>SUBSCRIBE SET</refentrytitle> </refmeta>

<refnamediv><refname>SUBSCRIBE SET</refname>

<refpurpose> Start replication of <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>SUBSCRIBE SET (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> Causes a node (subscriber) to start replicating a set of tables
either from the origin or from another provider node, which must be an
active, forwarding subscriber itself.

<para> The application tables contained in the set must already exist
and should ideally be empty. The current version of
<productname/Slony-I/ will <emphasis/not/ attempt to copy the schema
of the set. The replication daemon will start copying the current
content of the set from the given provider and then try to catch up
with any update activity that happened during that copy process. After
successful subscription, the tables are guarded on the subscriber,
using triggers, against accidental updates by the application.
</para>

<para> If the tables on the subscriber are <emphasis/not/ empty, then
the <command/COPY SET/ process winds up doing more work than should be
strictly necessary:
<itemizedlist>
<listitem><para> It deletes all <quote/old/ entries in the table
<listitem><para> Those old entries clutter up the table until it is next <command/VACUUM/ed <emphasis/after/ the subscription process is complete
<listitem><para> The indices for the table will contain entries for the old, deleted entries, which will slow the process of inserting new entries into the index.
</itemizedlist>


<note><para>
	If you need to revise subscription information for a
	node, you may submit the new information using this command,
	and the new configuration will be propagated throughout the
	replication network.  The normal reason to revise this
	information is that you want a node to subscribe to a <emphasis>
	different </emphasis> provider node, or for a node to become a
	<quote/forwarding/ subscriber so it may later become the
	provider
	for a later subscriber. </note>



<variablelist>
 <varlistentry><term><literal> ID = ival </literal></term>
  <listitem><para> ID of the set to subscribe

 </varlistentry>
 <varlistentry><term><literal> PROVIDER = ival </literal></term>

  <listitem><para> Node ID of the data provider from which this node draws data.

 </varlistentry>
 <varlistentry><term><literal> RECEIVER = ival </literal></term>

  <listitem><para> Node ID of the new subscriber

 </varlistentry>
 <varlistentry><term><literal> FORWARD = boolean </literal></term>

  <listitem><para> Flag whether or not the new subscriber should store
		the log information during replication to make it
		possible candidate for the provider role for future
		nodes.


 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
SUBSCRIBE SET (
   ID = 1,
   PROVIDER = 1,
   RECEIVER = 3,
   FORWARD = YES
);
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->

<refentry id ="stmtunsubscribeset"><refmeta><refentrytitle>UNSUBSCRIBE SET</refentrytitle> </refmeta>

<refnamediv><refname>UNSUBSCRIBE SET</refname>

<refpurpose> End replication of <productname/Slony-I/ set </refpurpose>

<refsynopsisdiv>
<cmdsynopsis>
<command>UNSUBSCRIBE SET (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> 
	Stops the subscriber from replicating the set. The tables are
	opened up for full access by the client application on the
	former subscriber. The tables are not truncated or otherwise
	modified. All original triggers, rules and constraints are
	restored.

<warning><para> Resubscribing an unsubscribed set requires a
<emphasis>complete fresh copy</emphasis> of data from the provider to
be transferred since the tables have been subject to possible
independent modifications.  </para></warning>

<variablelist>
 <varlistentry><term><literal> ID = ival </literal></term>
  <listitem><para> ID of the set to unsubscribe

 </varlistentry>
 <varlistentry><term><literal> RECEIVER = ival </literal></term>

  <listitem><para> Node ID of the (former) subscriber

 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
UNSUBSCRIBE SET (
   ID = 1,
   RECEIVER = 3
);
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtlockset"><refmeta><refentrytitle>LOCK SET</refentrytitle> </refmeta>

<refnamediv><refname>LOCK SET</refname>

<refpurpose> Configuration of <productname/Slony-I/ set </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>LOCK SET (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> 
	Guards a replication set against client application updates in
	preparation for a <link linkend="stmtmoveset">MOVE SET</link>
	command.
</para>
<para>
	This command must be the first in a possible statement group
	(<command>try</command>).  The reason for this is that it needs to
	commit the changes made to the tables (adding a special
	trigger function) before it can wait for every concurrent
	transaction to finish. At the same time it cannot hold an open
	transaction to the same database itself since this would
	result in blocking itself forever.


<variablelist>
 <varlistentry><term><literal> ID = ival </literal></term>
  <listitem><para> ID of the set to lock

 </varlistentry>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>

  <listitem><para> Node ID of the current set origin

 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
LOCK SET (
   ID = 1,
   RECEIVER = 3
);
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->

<refentry id ="stmtunlockset"><refmeta><refentrytitle>UNLOCK SET</refentrytitle> </refmeta>

<refnamediv><refname>UNLOCK SET</refname>

<refpurpose> Configuration of <productname/Slony-I/ set </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>UNLOCK SET (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> 
	Unlocks a previously locked set.


<variablelist>
 <varlistentry><term><literal> ID = ival </literal></term>
  <listitem><para> ID of the set to unlock

 </varlistentry>
 <varlistentry><term><literal> ORIGIN = ival </literal></term>

  <listitem><para> Node ID of the current set origin

 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
UNLOCK SET (
   ID = 1,
   RECEIVER = 3
);
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtmoveset"><refmeta><refentrytitle>MOVE SET</refentrytitle> </refmeta>

<refnamediv><refname>MOVE SET</refname>

<refpurpose> Reconfiguration of <productname/Slony-I/ set </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>MOVE SET (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> 
	Changes the origin of a set from one node to another. The new
	origin must be a current subscriber of the set. The set must
	currently be locked on the old origin. </para> 

<para>
	After this command, the set cannot be unlocked on the old
	origin any more. The old origin will continue as a forwarding
	subscriber of the set and the subscription chain from the old
	origin to the new origin will be reversed, hop by hop. As soon
	as the new origin has finished processing the event (that
	includes any outstanding sync events that happened before,
	<emphasis>i.e.</emphasis> fully catching up), the new origin
	will take over and open all tables in the set for client
	application update
	activity.
</para>
<para>
	This is <emphasis/not/ failover, as it requires a functioning
	old origin node (you needed to lock the set on the old
	origin).  You would probably prefer to <command/MOVE SET/
	instead of <command/FAILOVER/, if at all possible, as
	<command/FAILOVER/ winds up discarding the old origin node as
	being corrupted.


<variablelist>
 <varlistentry><term><literal> ID = ival </literal></term>
  <listitem><para> ID of the set to transfer

 </varlistentry>
 <varlistentry><term><literal> OLD ORIGIN = ival </literal></term>

  <listitem><para> Node ID of the current set origin

 </varlistentry>
 <varlistentry><term><literal> NEW ORIGIN = ival </literal></term>

  <listitem><para> Node ID of the new set origin

 </varlistentry>
</variablelist>
</para>
</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
MOVE SET (
   ID = 1,
   OLD ORIGIN = 1,
   NEW ORIGIN = 3
);
</Programlisting>
</Refsect1>
</Refentry>

<!-- **************************************** -->

<refentry id ="stmtfailover"><refmeta><refentrytitle>FAILOVER</refentrytitle> </refmeta>

<refnamediv><refname>FAILOVER</refname>

<refpurpose> Reconfiguration of <productname/Slony-I/ set </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>FAILOVER (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para>
	The failover command causes the backup node to take over all
	sets that currently originate on the failed node. <Application/Slonik/ will
	contact all other direct subscribers of the failed node to
	determine which node has the highest sync status for each
	set. If another node has a higher sync status than the backup
	node, the replication will first be redirected so that the
	backup node replicates against that other node, before
	assuming the origin role and allowing update activity.
</para>
<para>
	After successful failover, all former direct subscribers of
	the failed node become direct subscribers of the backup
	node. The failed node can and should be removed from the
	configuration with <command><link linkend="stmtdropnode"> DROP NODE</link> </command>.
</para>

<warning><para> This command will abandon the status of the failed
	node.  There is no possibility to let the failed node join the
	cluster again without rebuilding it from scratch as a slave
	slave.  It would often be highly preferable to use <command> <link linkend="stmtmoveset"> MOVE SET </link> </command> instead.
</para></warning>

<variablelist>
 <varlistentry><term><literal> ID = ival </literal></term>
  <listitem><para> ID of the failed node

 </varlistentry>
 <varlistentry><term><literal> BACKUP NODE = ival </literal></term>

  <listitem><para> Node ID of the node that will take over all sets originating on the failed node

 </varlistentry>
</variablelist>

</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
FAILOVER (
   ID = 1,
   BACKUP NODE = 2
);
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtddlscript"><refmeta><refentrytitle>EXECUTE SCRIPT</refentrytitle> </refmeta>

<refnamediv><refname>EXECUTE SCRIPT</refname>

<refpurpose> Reconfiguration of <productname/Slony-I/ set </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>EXECUTE SCRIPT (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> Executes a script containing arbitrary SQL statements on all
nodes that are subscribed to a set at a common controlled point within
the replication transaction stream.</para>

<para> The specified event origin must be the origin of the set.  The
script file must not contain any <command/START/ or <command/COMMIT
TRANSACTION/ calls.  (This may change in PostgreSQL 8.0 once nested
transactions, aka savepoints, are supported) In addition,
non-deterministic DML statements (like updating a field with
<function/CURRENT_TIMESTAMP/) must be avoided, since the data changes
done by the script are explicitly not replicated. </para>

<variablelist>
 <varlistentry><term><literal> SET ID = ival </literal></term>
  <listitem><para> The unique numeric ID number of the set affected by the script

 </varlistentry>
 <varlistentry><term><literal> FILENAME = '/path/to/file' </literal></term>

  <listitem><para> The name of the file containing the SQL script to
  execute.  This might be a relative path, relative to the location of
  the <application/slonik/ instance you are running, or, preferably,
  an absolute path on the system where <application/slonik/ is to run.

  <para> The <emphasis/contents/ of the file are propagated as part of
  the event, so the file does not need to be accessible on any of the
  nodes.

 </varlistentry>
 <varlistentry><term><literal> EVENT NODE = ival </literal></term>
  <listitem><para> (Optional) The ID of the current origin of the set.  Default value is 1.

 </varlistentry>
 <varlistentry><term><literal> EXECUTE ONLY ON = ival </literal></term>
  <listitem><para> (Optional)		The ID of the only node to actually execute the script.
		This option causes the script to be propagated by all nodes
		but executed only by one.
		The default is to execute the script on all nodes that are
		subscribed to the set.


 </varlistentry>
</variablelist>

<para> See also the warnings in <link linkend="ddlchanges"> Database
Schema Changes (DDL)</link>.

</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
EXECUTE SCRIPT (
   SET ID = 1,
   FILENAME = '/tmp/changes_2004-05-01.sql',
   EVENT NODE = 1
);
</Programlisting>
</Refsect1>
</Refentry>


<!-- **************************************** -->

<refentry id ="stmtwaitevent"><refmeta><refentrytitle>WAIT FOR EVENT</refentrytitle> </refmeta>

<refnamediv><refname>WAIT FOR EVENT</refname>

<refpurpose> Reconfiguration of <productname/Slony-I/ set </refpurpose>
<refsynopsisdiv>
<cmdsynopsis>
<command>WAIT FOR EVENT (options);</command>
</cmdsynopsis>
</refsynopsisdiv>
<refsect1>
<title>Description</title>

<para> Waits for event Confirmation.

<para> <Application/Slonik/ remembers the last event generated on
every node during script execution (events generated by earlier calls
are currently not checked). In certain situations it is necessary that
events generated on one node (such as <command>CREATE SET</command>)
are processed on another node before issuing more commands (for
instance, <link linkend="stmtsubscribeset"><command/SUBSCRIBE
SET/</link>).  <COMMAND>WAIT FOR EVENT</COMMAND> may be used to cause
the <application/slonik/ script to wait until the subscriber node is
ready for the next action.
</para>

<para> <command>WAIT FOR EVENT</command> must be called outside of any
<command/try/ block in order to work, since new confirm messages don't
become visible within a transaction.

<variablelist>
 <varlistentry><term><literal> ORIGIN = ival | ALL </literal></term>
  <listitem><para> The origin of the event(s) to wait for.

 </varlistentry>
 <varlistentry><term><literal> CONFIRMED = ival | ALL </literal></term>

  <listitem><para> The node ID of the receiver that must confirm the event(s).

 </varlistentry>
 <varlistentry><term><literal> WAIT ON = ival </literal></term>
  <listitem><para> The ID of the node where the sl_confirm table is to be checked.  The default value is 1.

 </varlistentry>
 <varlistentry><term><literal> TIMEOUT = ival </literal></term>

  <listitem><para> The number of seconds to wait.  Default is 600 (10
  minutes).  <command/TIMEOUT = 0/ causes the script to wait
  indefinitely.

 </varlistentry>
</variablelist>

</Refsect1>
<Refsect1><Title>Example</Title>
<Programlisting>
WAIT FOR EVENT (
  ORIGIN = ALL,
  CONFIRMED = ALL,
  WAIT ON = 1
);
</Programlisting>
</Refsect1>
</Refentry>
</reference>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
