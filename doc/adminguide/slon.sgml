<!-- $Id: slon.sgml,v 1.11 2005-02-17 23:42:07 cbbrowne Exp $ -->
<refentry id="app-slon">
 <refmeta>
  <refentrytitle id="app-slon-title"><application>slon</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>
 <refnamediv>
  <refname><application id="slon">slon</application></refname>
  <refpurpose>
   <productname>Slony-I</productname> daemon
  </refpurpose>
 </refnamediv>
 
 <indexterm zone="app-slon">
  <primary>slon</primary>
 </indexterm>
 
 <refsynopsisdiv>
  <cmdsynopsis>
   <command>slon</command>
   <arg rep="repeat"><replaceable class="parameter">option</replaceable></arg>
   <arg><replaceable class="parameter">clustername</replaceable></arg>
   <arg><replaceable class="parameter">conninfo</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>
 
 <refsect1>
  <title>Description</title>
  <para>
   <application>slon</application> is the daemon application that
   <quote>runs</quote> <productname>Slony-I</productname>
   replication.  A <application>slon</application> instance must be
   run for each node in a <productname>Slony-I</productname>
   cluster.
  </para>
 </refsect1>
 
 <refsect1 id="r1-app-slon-3">
  <title>Options</title>
  
  <variablelist>
   <varlistentry>
    <term><option>-d</option><replaceable class="parameter">debuglevel</replaceable></term>
    <listitem>
     <para>
      Specifies the level of verbosity that <application>slon</application> should
      use when logging its activity.
     </para>
     <para>
      The eight levels of logging are:
      <itemizedlist>
       <listitem><para>Error</para></listitem>
       <listitem><para>Warn</para></listitem>
       <listitem><para>Config</para></listitem>
       <listitem><para>Info</para></listitem>
       <listitem><para>Debug1</para></listitem>
       <listitem><para>Debug2</para></listitem>
       <listitem><para>Debug3</para></listitem>
       <listitem><para>Debug4</para></listitem>
      </itemizedlist>
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><option>-s</option><replaceable class="parameter">SYNC check interval</replaceable></term>
    <listitem>

     <para>
      Specifies the interval, in milliseconds, in which
      <application>slon</application> should check to see if a SYNC
      should be introduced even if none has been mandated by data
      creation.  Default is 10000 ms.
     </para>
     
     <para>
      Short sync times keep the origin on a <quote>short
      leash</quote>, updating its subscribers more frequently.  If you
      have replicated sequences that are frequently updated
      <emphasis>without</emphasis> there being tables that are
      affected, this keeps there from being times when only sequences
      are updated, and therefore <emphasis>no</emphasis> syncs take
      place
     </para>

     <para>
      If the node is not an origin, so no updates are coming in, it
      will continue on to the <option>-t</option> timeout and generate
      a SYNC anyways.
     </para>

    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><option>-t</option><replaceable class="parameter">SYNC
    interval timeout</replaceable></term>
    <listitem>

     <para>
      At the end of each such timeout period, a SYNC will be generated
      on the <quote>local</quote> node even if there has been no
      replicatable data updated that would have pushed out a SYNC.
     </para>
     <para>
      Default is 60000 ms.
     </para>
     <para>
      Note that SYNC events are also generated on subscriber nodes.
      Since they are not actually generating any data to replicate to
      other nodes, such SYNC events are of little value.  You might
      want to increase this parameter to something quite a bit higher
      than the <option>-s</option> SYNC check interval, so that
      subscriber nodes won't generate and propagate as many SYNC
      events.  The once per minute that is the default seems amply
      often.
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><option>-g</option><replaceable class="parameter">group size</replaceable></term>
    <listitem>
     <para>
      Maximum SYNC group size; defaults to 6.  Thus, if a particular
      node is behind by 200 SYNCs, it will try to group them together
      into groups of 6.  This would be expected to reduce transaction
      overhead due to having fewer transactions to <command>COMMIT</command>.
     </para>
     <para>
      The default of 6 is probably suitable for small systems
      that can devote only very limited bits of memory to slon.  If you
      have plenty of memory, it would be reasonable to increase this,
      as it will increase the amount of work done in each transaction,
      and will allow a subscriber that is behind by a lot to catch up
      more quickly.
     </para>
     <para>
      Slon processes usually stay pretty small; even with large
      value for this option, slon would be expected to only grow to a
      few MB in size.
     </para>
     <para>
      The big advantage in increasing this parameter comes from
      cutting down on the number of transaction
      <command>COMMIT</command>s; moving from 1 to 2 should provide
      substantial benefit, but the benefits will progressively fall
      off once the transactions being processed get to be reasonably
      large.  There isn't likely to be a material difference in
      performance between 80 and 90; at that point, whether
      <quote>bigger is better</quote> will depend on whether the
      bigger set of SYNCs makes the LOG cursor behave badly due to
      consuming more memory and requiring more time to sortt.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><option>-o</option><replaceable class="parameter">desired sync time</replaceable></term>
    <listitem><para> A <quote>maximum</quote> time planned for grouped SYNCs.</para>

     <para> If replication is running behind, slon will gradually
      increase the numbers of SYNCs grouped together, targetting that
      (based on the time taken for the <emphasis>last</emphasis> group
      of SYNCs) they shouldn't take more than ths specified
      <quote>desired sync time</quote>.</para>

     <para> The default value is 60000ms, equal to one minute. </para>

     <para> That way, you can expect (or at least hope!) that you'll
      get a <command>COMMIT</command> roughly once per minute. </para>

     <para> It isn't <emphasis>totally</emphasis> predictable, as it
     is entirely possible for someone to request a <emphasis>very
     large update,</emphasis> all as one transaction, that can
     <quote>blow up</quote> the length of the resulting SYNC to be
     nearly arbitrarily long.  In such a case, the heuristic will back
     off for the <emphasis>next</emphasis> group.</para>

     <para> The overall effect is to improve
      <productname>Slony-I</productname>'s ability to cope with
      variations in traffic.  By starting with 1 SYNC, and gradually
      moving to more, even if there turn out to be variations large
      enough to cause <productname>PostgreSQL</productname> backends to
      crash, <productname>Slony-I</productname> will back off down to
      start with one sync at a time, if need be, so that if it is at
      all possible for replication to progress, it will.</para>
    </listitem>
   </varlistentry>      

   <varlistentry>
    <term><option>-c</option><replaceable class="parameter">cleanup cycles</replaceable></term>
    <listitem>
     <para>
      How often to <command>VACUUM</command> in cleanup cycles.
     </para>
     <para>
      Set this to zero to disable
      <application>slon</application>-initiated vacuuming. If you are
      using something like <application>pg_autovacuum</application> to
      initiate vacuums, you may not need for slon to initiate vacuums
      itself.  If you are not, there are some tables
      <productname>Slony-I</productname> uses that collect a
      <emphasis>lot</emphasis> of dead tuples that should be vacuumed
      frequently.
     </para>
    </listitem>
   </varlistentry>
   
   
   <varlistentry>
    <term><option>-p</option><replaceable class="parameter">PID filename</replaceable></term>
    <listitem>
     <para>
      Filename in which the PID (process ID) of the <application>slon</application> is stored.
     </para>
    </listitem>
   </varlistentry>
   
   <varlistentry>
    <term><option>-f</option><replaceable class="parameter">config file</replaceable></term>
    <listitem>
     <para>
      File from which to read <application>slon</application> configuration.
     </para>
    </listitem>
   </varlistentry>
   <varlistentry>
    <term><option>-a</option><replaceable class="parameter">archive directory</replaceable></term>
    <listitem>
     <para>
      Directory in which to place a sequence of SYNC archive files for
      use in <quote>log shipping</quote> mode.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>
 <refsect1>
  <title>Exit Status</title>
  <para>
   <application>slon</application> returns 0 to the shell if it
   finished normally.  It returns -1 if it encounters any fatal error.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:"book.sgml"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
