<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
> Slony Listen Paths</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:cbbrowne@gmail.com"><LINK
REL="HOME"
TITLE="Slony-I 1.1 Administration"
HREF="slony.html"><LINK
REL="UP"
HREF="slonyadmin.html"><LINK
REL="PREVIOUS"
TITLE="Doing switchover and failover with Slony-I"
HREF="failover.html"><LINK
REL="NEXT"
TITLE=" Adding Things to Replication"
HREF="addthings.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stdstyle.css"><META
HTTP-EQUIV="Content-Type"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Slony-I 1.1 Administration</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="failover.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="addthings.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LISTENPATHS"
>8. Slony Listen Paths</A
></H1
><P
>If you have more than two or three nodes, and any degree of
usage of cascaded subscribers (_e.g._ - subscribers that are
subscribing through a subscriber node), you will have to be fairly
careful about the configuration of "listen paths" via the Slonik STORE
LISTEN and DROP LISTEN statements that control the contents of the
table sl_listen.&#13;</P
><P
>The "listener" entries in this table control where each node
expects to listen in order to get events propagated from other nodes.
You might think that nodes only need to listen to the "parent" from
whom they are getting updates, but in reality, they need to be able to
receive messages from _all_ nodes in order to be able to conclude that
SYNCs have been received everywhere, and that, therefore, entries in
sl_log_1 and sl_log_2 have been applied everywhere, and can therefore
be purged.&#13;</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN744"
>8.1. How Listening Can Break</A
></H2
><P
>On one occasion, I had a need to drop a subscriber node (#2) and
recreate it.  That node was the data provider for another subscriber
(#3) that was, in effect, a "cascaded slave."  Dropping the subscriber
node initially didn't work, as slonik informed me that there was a
dependant node.  I repointed the dependant node to the "master" node
for the subscription set, which, for a while, replicated without
difficulties.&#13;</P
><P
>I then dropped the subscription on "node 2," and started
resubscribing it.  That raised the Slony-I <TT
CLASS="COMMAND"
>SET_SUBSCRIPTION</TT
>
event, which started copying tables.  At that point in time, events
stopped propagating to "node 3," and while it was in perfectly OK
shape, no events were making it to it.&#13;</P
><P
>The problem was that node #3 was expecting to receive events
from node #2, which was busy processing the <TT
CLASS="COMMAND"
>SET_SUBSCRIPTION</TT
> event,
and was not passing anything else on.&#13;</P
><P
>We dropped the listener rules that caused node #3 to listen to
node 2, replacing them with rules where it expected its events to come
from node #1 (the "master" provider node for the replication set).  At
that moment, "as if by magic," node #3 started replicating again, as
it discovered a place to get <TT
CLASS="COMMAND"
>SYNC</TT
> events.&#13;</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN753"
>8.2. How The Listen Configuration Should Look</A
></H2
><P
>The simple cases tend to be simple to cope with.  We'll look at
a fairly complex set of nodes.&#13;</P
><P
>Consider a set of nodes, 1 thru 6, where 1 is the "master,"
where 2-4 subscribe directly to the master, and where 5 subscribes to
2, and 6 subscribes to 5.&#13;</P
><P
>Here is a "listener network" that indicates where each node
should listen for messages coming from each other node:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>           1|   2|   3|   4|   5|   6|
    --------------------------------------------
       1   0    2    3    4    2    2 
       2   1    0    1    1    5    5 
       3   1    1    0    1    1    1 
       4   1    1    1    0    1    1 
       5   2    2    2    2    0    6 
       6   5    5    5    5    5    0 </PRE
></TD
></TR
></TABLE
>&#13;</P
><P
>Row 2 indicates all of the listen rules for node 2; it gets
events for nodes 1, 3, and 4 throw node 1, and gets events for nodes 5
and 6 from node 5.&#13;</P
><P
>The row of 5's at the bottom, for node 6, indicate that node 6
listens to node 5 to get events from nodes 1-5.&#13;</P
><P
>The set of slonik <TT
CLASS="COMMAND"
>SET LISTEN</TT
> statements to express
this <SPAN
CLASS="QUOTE"
>"listener network"</SPAN
> are as follows:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>    store listen (origin = 1, receiver = 2, provider = 1);
    store listen (origin = 1, receiver = 3, provider = 1);
    store listen (origin = 1, receiver = 4, provider = 1);
    store listen (origin = 1, receiver = 5, provider = 2);
    store listen (origin = 1, receiver = 6, provider = 5);
    store listen (origin = 2, receiver = 1, provider = 2);
    store listen (origin = 2, receiver = 3, provider = 1);
    store listen (origin = 2, receiver = 4, provider = 1);
    store listen (origin = 2, receiver = 5, provider = 2);
    store listen (origin = 2, receiver = 6, provider = 5);
    store listen (origin = 3, receiver = 1, provider = 3);
    store listen (origin = 3, receiver = 2, provider = 1);
    store listen (origin = 3, receiver = 4, provider = 1);
    store listen (origin = 3, receiver = 5, provider = 2);
    store listen (origin = 3, receiver = 6, provider = 5);
    store listen (origin = 4, receiver = 1, provider = 4);
    store listen (origin = 4, receiver = 2, provider = 1);
    store listen (origin = 4, receiver = 3, provider = 1);
    store listen (origin = 4, receiver = 5, provider = 2);
    store listen (origin = 4, receiver = 6, provider = 5);
    store listen (origin = 5, receiver = 1, provider = 2);
    store listen (origin = 5, receiver = 2, provider = 5);
    store listen (origin = 5, receiver = 3, provider = 1);
    store listen (origin = 5, receiver = 4, provider = 1);
    store listen (origin = 5, receiver = 6, provider = 5);
    store listen (origin = 6, receiver = 1, provider = 2);
    store listen (origin = 6, receiver = 2, provider = 5);
    store listen (origin = 6, receiver = 3, provider = 1);
    store listen (origin = 6, receiver = 4, provider = 1);
    store listen (origin = 6, receiver = 5, provider = 6);</PRE
></TD
></TR
></TABLE
>&#13;</P
><P
>How we read these listen statements is thus...&#13;</P
><P
>When on the "receiver" node, look to the "provider" node to
provide events coming from the "origin" node.&#13;</P
><P
>The tool <TT
CLASS="FILENAME"
>init_cluster.pl</TT
> in the <TT
CLASS="FILENAME"
>altperl</TT
>
scripts produces optimized listener networks in both the tabular form
shown above as well as in the form of Slonik statements.&#13;</P
><P
>There are three "thorns" in this set of roses:
<P
></P
><UL
><LI
><P
> If you change the shape of the node set, so that the
nodes subscribe differently to things, you need to drop sl_listen
entries and create new ones to indicate the new preferred paths
between nodes.  There is no automated way at this point to do this
"reshaping."&#13;</P
></LI
><LI
><P
> If you <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>don't</I
></SPAN
> change the sl_listen entries,
events will likely continue to propagate so long as all of the nodes
continue to run well.  The problem will only be noticed when a node is
taken down, "orphaning" any nodes that are listening through it.&#13;</P
></LI
><LI
><P
> You might have multiple replication sets that have
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>different</I
></SPAN
> shapes for their respective trees of subscribers.  There
won't be a single "best" listener configuration in that case.&#13;</P
></LI
><LI
><P
> In order for there to be an sl_listen path, there
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>must</I
></SPAN
> be a series of sl_path entries connecting the origin
to the receiver.  This means that if the contents of sl_path do not
express a "connected" network of nodes, then some nodes will not be
reachable.  This would typically happen, in practice, when you have
two sets of nodes, one in one subnet, and another in another subnet,
where there are only a couple of "firewall" nodes that can talk
between the subnets.  Cut out those nodes and the subnets stop
communicating.&#13;</P
></LI
></UL
>&#13;</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN783"
>8.3. Open Question</A
></H2
><P
>I am not certain what happens if you have multiple listen path
entries for one path, that is, if you set up entries allowing a node
to listen to multiple receivers to get events from a particular
origin.  Further commentary on that would be appreciated!

<DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="./images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Actually, I do have answers to this; the remainder of
this document should be re-presented based on the fact that Slony-I
1.1 will include a "heuristic" to generate the listener paths
automatically. </P
></TD
></TR
></TABLE
></DIV
>&#13;</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN788"
>8.4. Generating listener entries via heuristics</A
></H2
><P
>It ought to be possible to generate sl_listen entries
dynamically, based on the following heuristics.  Hopefully this will
take place in version 1.1, eliminating the need to configure this by
hand.&#13;</P
><P
>Configuration will (tentatively) be controlled based on two data
sources:

<P
></P
><UL
><LI
><P
> sl_subscribe entries are the first, most vital
control as to what listens to what; we know there must be a "listen"
entry for a subscriber node to listen to its provider for events from
the provider, and there should be direct "listening" taking place
between subscriber and provider.&#13;</P
></LI
><LI
><P
> sl_path entries are the second indicator; if
sl_subscribe has not already indicated "how to listen," then a node
may listen directly to the event's origin if there is a suitable
sl_path entry&#13;</P
></LI
><LI
><P
> If there is no guidance thus far based on the above
data sources, then nodes can listen indirectly if there is an sl_path
entry that points to a suitable sl_listen entry...&#13;</P
></LI
></UL
>&#13;</P
><P
> A stored procedure would run on each node, rewriting sl_listen
each time sl_subscribe or sl_path are modified.


 </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="failover.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="slony.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="addthings.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Doing switchover and failover with Slony-I</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="slonyadmin.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Adding Things to Replication</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>