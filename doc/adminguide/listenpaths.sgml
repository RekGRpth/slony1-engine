<sect1 id="listenpaths"> <title/ Slony Listen Paths/

<note> <para> If you are running version <productname>Slony-I</productname> 1.1, it
should be <emphasis>completely unnecessary</emphasis> to read this section as it
introduces a way to automatically manage this part of its
configuration.  For earlier versions, however, it is needful...</para>
</note>

<para>If you have more than two or three nodes, and any degree of
usage of cascaded subscribers (<emphasis/e.g./ - subscribers that are
subscribing through a subscriber node), you will have to be fairly
careful about the configuration of <quote/listen paths/ via the Slonik <command/STORE
LISTEN/ and <command/DROP LISTEN/ statements that control the contents of the
table sl_listen.

<para>The <quote/listener/ entries in this table control where each
node expects to listen in order to get events propagated from other
nodes.  You might think that nodes only need to listen to the
<quote/parent/ from whom they are getting updates, but in reality,
they need to be able to receive messages from <emphasis/all/ nodes in
order to be able to conclude that SYNCs have been received everywhere,
and that, therefore, entries in sl_log_1 and sl_log_2 have been
applied everywhere, and can therefore be purged.  This extra
communication is needful so <productname/Slony-I/ is able to shift
origins to other locations.

<sect2><title/ How Listening Can Break/

<para>On one occasion, I had a need to drop a subscriber node (#2) and
recreate it.  That node was the data provider for another subscriber
(#3) that was, in effect, a <quote/cascaded slave./ Dropping the
subscriber node initially didn't work, as <link linkend="slonik">
<command/slonik/ </link> informed me that there was a dependant node.
I repointed the dependant node to the <quote/master/ node for the
subscription set, which, for a while, replicated without difficulties.

<para>I then dropped the subscription on <quote/node 2,/ and started
resubscribing it.  That raised the <productname/Slony-I/
<command/SET_SUBSCRIPTION/ event, which started copying tables.  At
that point in time, events stopped propagating to <quote/node 3,/ and
while it was in perfectly OK shape, no events were making it to it.

<para>The problem was that node #3 was expecting to receive events
from node #2, which was busy processing the <command/SET_SUBSCRIPTION/
event, and was not passing anything else on.

<para>We dropped the listener rules that caused node #3 to listen to
node 2, replacing them with rules where it expected its events to come
from node #1 (the origin node for the replication set).  At that
moment, <quote/as if by magic,/ node #3 started replicating again, as
it discovered a place to get <command/SYNC/ events.

<sect2><title/How The Listen Configuration Should Look/

<para>The simple cases tend to be simple to cope with.  We need to
instead look at a more complex node configuration.

<para>Consider a set of nodes, 1 thru 6, where 1 is the origin, 
where 2-4 subscribe directly to the origin, and where 5 subscribes to
2, and 6 subscribes to 5.

<para>Here is a <quote/listener network/ that indicates where each
node should listen for messages coming from each other node:

<screen>
       1|   2|   3|   4|   5|   6|
--------------------------------------------
   1   0    2    3    4    2    2 
   2   1    0    1    1    5    5 
   3   1    1    0    1    1    1 
   4   1    1    1    0    1    1 
   5   2    2    2    2    0    6 
   6   5    5    5    5    5    0 
</screen>

<para>Row 2 indicates all of the listen rules for node 2; it gets
events for nodes 1, 3, and 4 throw node 1, and gets events for nodes 5
and 6 from node 5.

<para>The row of 5's at the bottom, for node 6, indicate that node 6
listens to node 5 to get events from nodes 1-5.

<para>The set of slonik <command/SET LISTEN/ statements to express
this <quote/listener network/ are as follows:

<programlisting>
store listen (origin = 1, receiver = 2, provider = 1);
store listen (origin = 1, receiver = 3, provider = 1);
store listen (origin = 1, receiver = 4, provider = 1);
store listen (origin = 1, receiver = 5, provider = 2);
store listen (origin = 1, receiver = 6, provider = 5);
store listen (origin = 2, receiver = 1, provider = 2);
store listen (origin = 2, receiver = 3, provider = 1);
store listen (origin = 2, receiver = 4, provider = 1);
store listen (origin = 2, receiver = 5, provider = 2);
store listen (origin = 2, receiver = 6, provider = 5);
store listen (origin = 3, receiver = 1, provider = 3);
store listen (origin = 3, receiver = 2, provider = 1);
store listen (origin = 3, receiver = 4, provider = 1);
store listen (origin = 3, receiver = 5, provider = 2);
store listen (origin = 3, receiver = 6, provider = 5);
store listen (origin = 4, receiver = 1, provider = 4);
store listen (origin = 4, receiver = 2, provider = 1);
store listen (origin = 4, receiver = 3, provider = 1);
store listen (origin = 4, receiver = 5, provider = 2);
store listen (origin = 4, receiver = 6, provider = 5);
store listen (origin = 5, receiver = 1, provider = 2);
store listen (origin = 5, receiver = 2, provider = 5);
store listen (origin = 5, receiver = 3, provider = 1);
store listen (origin = 5, receiver = 4, provider = 1);
store listen (origin = 5, receiver = 6, provider = 5);
store listen (origin = 6, receiver = 1, provider = 2);
store listen (origin = 6, receiver = 2, provider = 5);
store listen (origin = 6, receiver = 3, provider = 1);
store listen (origin = 6, receiver = 4, provider = 1);
store listen (origin = 6, receiver = 5, provider = 6);
</programlisting>

<para>How we read these listen statements is thus...

<para>When on the <quote/receiver/ node, look to the <quote/provider/
node to provide events coming from the <quote/origin/ node.

<para>The tool <filename/init_cluster.pl/ in the <filename/altperl/
scripts produces optimized listener networks in both the tabular form
shown above as well as in the form of <link linkend="Slonik">
<application/slonik/ </link> statements.

<para>There are three <quote/thorns/ in this set of roses:

<itemizedlist>

<listitem><para> If you change the shape of the node set, so that the
nodes subscribe differently to things, you need to drop sl_listen
entries and create new ones to indicate the new preferred paths
between nodes.  Until <productname/Slony-I/, there is no automated way
at this point to do this <quote/reshaping./

<listitem><para> If you <emphasis/don't/ change the sl_listen entries,
events will likely continue to propagate so long as all of the nodes
continue to run well.  The problem will only be noticed when a node is
taken down, <quote/orphaning/ any nodes that are listening through it.

<listitem><para> You might have multiple replication sets that have
<emphasis/different/ shapes for their respective trees of subscribers.
There won't be a single <quote/best/ listener configuration in that
case.

<listitem><para> In order for there to be an sl_listen path, there
<emphasis/must/ be a series of sl_path entries connecting the origin
to the receiver.  This means that if the contents of sl_path do not
express a <quote/connected/ network of nodes, then some nodes will not
be reachable.  This would typically happen, in practice, when you have
two sets of nodes, one in one subnet, and another in another subnet,
where there are only a couple of <quote/firewall/ nodes that can talk
between the subnets.  Cut out those nodes and the subnets stop
communicating.

</itemizedlist>

<sect2><title/Automated Listen Path Generation/

<para> In <productname/Slony-I/ version 1.1, a heuristic scheme is
introduced to automatically generate listener entries.  This happens,
in order, based on three data sources:

<itemizedlist>

<listitem><para> sl_subscribe entries are the first, most vital
control as to what listens to what; we <emphasis/know/ there must be a
direct path between each subscriber node and its provider.

<listitem><para> sl_path entries are the second indicator; if
sl_subscribe has not already indicated <quote/how to listen,/ then a
node may listen directly to the event's origin if there is a suitable
sl_path entry.

<listitem><para> Lastly, if there has been no guidance thus far based
on the above data sources, then nodes can listen indirectly via every
node that is either a provider for the receiver, or that is using the
receiver as a provider.

</itemizedlist>

<para> Any time sl_subscribe or sl_path are modified,
<function>RebuildListenEntries()</function> will be called to revise
the listener paths.</para>
</sect1>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
