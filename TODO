ToDo List for Slony-I
-----------------------------------------

$Id: TODO,v 1.9 2007-07-11 17:21:31 cbbrowne Exp $

Documentation Improvements
--------------------------------------------

- Removed all support for STORE/DROP TRIGGER commands. Users are
  supposed to use the ALTER TABLE [ENABLE|DISABLE] TRIGGER
  functionality in Postgres from now on.

  There is now mention of this in docs/adminguide/slonyupgrade.sgml;
  need to enhance it further after discussion with Jan Wieck.

Short Term Items
---------------------------

CANCEL SUBSCRIPTION
   <http://lists.slony.info/pipermail/slony1-hackers/2007-May/000011.html>

Improve script that tries to run UPDATE FUNCTIONS across versions to
verify that upgrades work properly.

- update autoconf to be better aware of where DocBook document
  generation tools live

- Clone Node - use pg_dump/PITR to populate a new subscriber node

  Jan working on this

Longer Term Items
---------------------------

- Add more tests (what???) to test_slony_state script(s).

  e.g. - add a warning if there exist tables with generated PK.

  Arguably, that isn't really a good thing to do; if there is a table
  with column generated via TABLE ADD KEY, then we have the
  undesirable result that there will be an error/warning reported
  every time test_slony_state is run.

  Perhaps there should be a second script that looks for "static"
  problems, so we can leave test_slony_state to look for "dynamic"
  problems.

- Use PGXS

- Windows-compatible version of tools/slony1_dump.sh

Wishful Thinking
----------------------------

SYNC pipelining

  - the notion here is to open two connections to the source DB, and
    to start running the queries to generate the next LOG cursor while
    the previous request is pushing INSERT/UPDATE/DELETE requests to
    the subscriber.

COPY pipelining

  - the notion here is to try to parallelize the data load at
    SUBSCRIBE time.  Suppose we decide we can process 4 tables at a
    time, we set up 4 threads.  We then iterate thus:

    For each table
       - acquire a thread (waiting as needed)
       - submit COPY TO stdout to the provider, and feed to 
         COPY FROM stdin on the subscriber
       - Submit the REINDEX request on the subscriber

    Even with a fairly small number of threads, we should be able to
    process the whole subscription in as long as it takes to process
    the single largest table.

    This introduces a risk of locking problems not true at present
    (alas) in that, at present, the subscription process is able to
    demand exclusive locks on all tables up front; that is no longer
    possible if the subscriptions are split across multiple tables.
    In addition, the updates will COMMIT across some period of time on
    the subscriber rather than appearing at one instant in time.

    The timing improvement is probably still worthwhile.

    http://lists.slony.info/pipermail/slony1-hackers/2007-April/000000.html

Slonik ALTER TABLE event

    This would permit passing through changes targeted at a single
    table, and require much less extensive locking than traditional
    EXECUTE SCRIPT.

Compress DELETE/UPDATE/INSERT requests

    Some performance benefits could be gotten by compressing sets of
    DELETEs on the same table into a single DELETE statement.  This
    doesn't help the time it takes to fire triggers on the origin, but
    can speed the process of "mass" deleting records on subscribers.

    <http://lists.slony.info/pipermail/slony1-general/2007-July/006249.html>

    Unfortunately, this would complicate the application code, which
    people agreed would be a net loss...

    <http://lists.slony.info/pipermail/slony1-general/2007-July/006267.html>

Data Transformations on Subscriber

    Have an alternative "logtrigger()" scheme which permits creating a
    custom logtrigger function that can read both OLD.* and NEW.* and
    assortedly:

    - Omit columns on a subscriber
    - Omit tuples
