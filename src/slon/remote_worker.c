/*-------------------------------------------------------------------------
 * remote_worker.c
 *
 *	Implementation of the thread processing remote events.
 *
 *	Copyright (c) 2003-2004, PostgreSQL Global Development Group
 *	Author: Jan Wieck, Afilias USA INC.
 *
 *	$Id: remote_worker.c,v 1.3 2004-02-25 19:47:37 wieck Exp $
 *-------------------------------------------------------------------------
 */


#include <pthread.h>

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <signal.h>
#include <sys/time.h>
#include <sys/types.h>

#include "libpq-fe.h"
#include "c.h"

#include "slon.h"


/* ----------
 * Local definitions
 * ----------
 */

/*
 * Internal message types
 */
#define	WMSG_EVENT		0
#define WMSG_WAKEUP		1
#define WMSG_CONFIRM	2


/*
 * Message structure resulting from a remote event
 */
struct slon_work_message_event {
	int			msg_type;
	struct slon_work_message *prev;
	struct slon_work_message *next;

	int			ev_origin;
	int64		ev_seqno;
	char	   *ev_timestamp_c;
	char	   *ev_minxid_c;
	char	   *ev_maxxid_c;
	char	   *ev_xip;
	char	   *ev_type;
	char	   *ev_data1;
	char	   *ev_data2;
	char	   *ev_data3;
	char	   *ev_data4;
	char	   *ev_data5;
	char	   *ev_data6;
	char	   *ev_data7;
	char	   *ev_data8;
	char		raw_data[1];
};


/*
 * Message structure resulting from a remote confirm
 */
struct slon_work_message_confirm {
	int			msg_type;
	struct slon_work_message *prev;
	struct slon_work_message *next;

	int			con_origin;
	int			con_received;
	int64		con_seqno;
	char		con_timestamp_c[64];
};


/*
 * Generic message header
 */
struct slon_work_message {
	int			msg_type;
	struct slon_work_message *prev;
	struct slon_work_message *next;
};


/*
 * Global status for all remote worker threads, remembering the
 * last seen confirmed sequence number.
 */
struct node_confirm_status {
	int			con_origin;
	int			con_received;
	int64		con_seqno;

	struct node_confirm_status	*prev;
	struct node_confirm_status	*next;
};
static struct node_confirm_status  *node_confirm_head = NULL;
static struct node_confirm_status  *node_confirm_tail = NULL;
pthread_mutex_t						node_confirm_lock = PTHREAD_MUTEX_INITIALIZER;


/* ----------
 * Local functions
 * ----------
 */
static int	query_execute(SlonNode *node, PGconn *dbconn, 
					SlonDString *dsp, int expected_rc);
static void	query_append_event(SlonDString *dsp, 
					struct slon_work_message_event *event);
static void	store_confirm_forward(SlonNode *node, SlonConn *conn,
					struct slon_work_message_confirm *confirm);
static int	copy_set(SlonNode *node, SlonConn *local_conn, int set_id);


/* ----------
 * slon_remoteWorkerThread
 *
 *	Listen for events on the local database connection. This means,
 *	events generated by the local node only.
 * ----------
 */
void *
remoteWorkerThread_main(void *cdata)
{
	SlonNode   *node = (SlonNode *)cdata;
	SlonConn   *local_conn;
	PGconn	   *local_dbconn;
	SlonDString	query1;
	struct slon_work_message	   *msg;
	struct slon_work_message_event *event;
	int			check_config = true;
	char		seqbuf[64];

	slon_log(SLON_DEBUG1,
			"remoteWorkerThread_%d: thread starts\n", 
			node->no_id);
	/*
	 * Connect to the local database
	 */
	if ((local_conn = slon_connectdb(rtcfg_conninfo, "remote_worker")) == NULL)
		slon_abort();
	local_dbconn = local_conn->dbconn;

	/*
	 * Initialize local data
	 */
	dstring_init(&query1);

	/*
	 * Put the connection into replication mode.
	 */
	slon_mkquery(&query1,
			"select %s.setSessionRole('_%s', 'slon'); ",
			rtcfg_namespace, rtcfg_cluster_name);
	if (query_execute(node, local_dbconn, &query1, PGRES_TUPLES_OK) < 0)
		slon_abort();

	/*
	 * Work until shutdown or node destruction
	 */
	while (true)
	{
		/*
		 * If we got the special WMSG_WAKEUP, check the current runmode
		 * of the scheduler and the status of our node.
		 */
		if (check_config)
		{
			if (sched_get_status() != SCHED_STATUS_OK)
				break;

			rtcfg_lock();
			if (!node->no_active)
				break;
			if (node->worker_status != SLON_TSTAT_RUNNING)
				break;
			rtcfg_unlock();

			check_config = false;
		}

		/*
		 * Receive the next message from the queue. If there is no
		 * one present, wait on the condition variable.
		 */
		pthread_mutex_lock(&(node->message_lock));
		if (node->message_head == NULL)
		{
			pthread_cond_wait(&(node->message_cond), &(node->message_lock));
			if (node->message_head == NULL)
			{
				slon_log(SLON_FATAL,
						"remoteWorkerThread_%d: got message "
						"condition but queue is empty\n",
						node->no_id);
				slon_abort();
			}
		}
		msg = node->message_head;
		DLLIST_REMOVE(node->message_head, node->message_tail, msg);
		pthread_mutex_unlock(&(node->message_lock));

		/*
		 * Process WAKEUP messages by simply setting the check_config
		 * flag.
		 */
		if (msg->msg_type == WMSG_WAKEUP)
		{
			free(msg);
			check_config = true;
			continue;
		}

		/*
		 * Process confirm messages.
		 */
		if (msg->msg_type == WMSG_CONFIRM)
		{
			store_confirm_forward(node, local_conn,
					(struct slon_work_message_confirm *)msg);
			free(msg);
			continue;
		}

		/*
		 * This must be an event message then.
		 */
		if (msg->msg_type != WMSG_EVENT)
		{
			slon_log(SLON_FATAL,
					"remoteWorkerThread_%d: unknown WMSG type %d\n",
					node->no_id, msg->msg_type);
			slon_abort();
		}

		event = (struct slon_work_message_event *)msg;
		sprintf(seqbuf, "%lld", event->ev_seqno);

		/*
		 * Construct the queries to begin a transaction, notify on
		 * the event and confirm relations, insert the event into our
		 * local sl_event table and confirm it in our local sl_confirm
		 * table. When this transaction commits, every other remote
		 * node listening for events with us as a provider will pick
		 * up the news.
		 */
		slon_mkquery(&query1, "begin transaction; ");
		query_append_event(&query1, event);
		
		/*
		 * Event type specific processing
		 */
		if (strcmp(event->ev_type, "SYNC") == 0)
		{
			/*
			 * SYNC event
			 */
printf("TODO: ********** remoteWorkerThread: node %d - EVENT %d,%lld %s - need to replicate\n",
node->no_id, event->ev_origin, event->ev_seqno, event->ev_type);
			slon_appendquery(&query1, "commit transaction;");
			if (query_execute(node, local_dbconn, &query1, PGRES_COMMAND_OK) < 0)
				slon_abort();
		}
		else
		{
			/*
			 * Simple configuration events. Call the corresponding
			 * runtime config function, add the query to call the
			 * configuration event specific stored procedure.
			 */
			if (strcmp(event->ev_type, "STORE_NODE") == 0)
			{
				int		no_id = (int) strtol(event->ev_data1, NULL, 10);
				char   *no_comment = event->ev_data2;

				if (no_id != rtcfg_nodeid)
					rtcfg_storeNode(no_id, no_comment);

				slon_appendquery(&query1,
						"select %s.storeNode_int(%d, '%q'); ",
						rtcfg_namespace,
						no_id, no_comment);
			}
			else if (strcmp(event->ev_type, "ENABLE_NODE") == 0)
			{
				int		no_id = (int) strtol(event->ev_data1, NULL, 10);

				if (no_id != rtcfg_nodeid)
					rtcfg_enableNode(no_id);

				slon_appendquery(&query1,
						"select %s.enableNode_int(%d); ",
						rtcfg_namespace,
						no_id);
			}
			else if (strcmp(event->ev_type, "STORE_PATH") == 0)
			{
				int		pa_server = (int) strtol(event->ev_data1, NULL, 10);
				int		pa_client = (int) strtol(event->ev_data2, NULL, 10);
				char   *pa_conninfo = event->ev_data3;
				int		pa_connretry = (int) strtol(event->ev_data4, NULL, 10);

				if (pa_client == rtcfg_nodeid)
					rtcfg_storePath(pa_server, pa_conninfo, pa_connretry);

				slon_appendquery(&query1,
						"select %s.storePath_int(%d, %d, '%q', %d); ",
						rtcfg_namespace,
						pa_server, pa_client, pa_conninfo, pa_connretry);
			}
			else if (strcmp(event->ev_type, "STORE_LISTEN") == 0)
			{
				int		li_origin = (int) strtol(event->ev_data1, NULL, 10);
				int		li_provider = (int) strtol(event->ev_data2, NULL, 10);
				int		li_receiver = (int) strtol(event->ev_data3, NULL, 10);

				if (li_receiver == rtcfg_nodeid)
					rtcfg_storeListen(li_origin, li_provider);

				slon_appendquery(&query1,
						"select %s.storeListen_int(%d, %d, %d); ",
						rtcfg_namespace,
						li_origin, li_provider, li_receiver);
			}
			else if (strcmp(event->ev_type, "STORE_SET") == 0)
			{
				int		set_id = (int) strtol(event->ev_data1, NULL, 10);
				int		set_origin = (int) strtol(event->ev_data2, NULL, 10);
				char   *set_comment = event->ev_data3;

				if (set_origin != rtcfg_nodeid)
					rtcfg_storeSet(set_id, set_origin, set_comment);

				slon_appendquery(&query1,
						"select %s.storeSet_int(%d, %d, '%q'); ",
						rtcfg_namespace,
						set_id, set_origin, set_comment);
			}
			else if (strcmp(event->ev_type, "SUBSCRIBE_SET") == 0)
			{
				int		sub_set = (int) strtol(event->ev_data1, NULL, 10);
				int		sub_provider = (int) strtol(event->ev_data2, NULL, 10);
				int		sub_receiver = (int) strtol(event->ev_data3, NULL, 10);
				char   *sub_forward = event->ev_data4;

				if (sub_receiver == rtcfg_nodeid)
					rtcfg_storeSubscribe(sub_set, sub_provider, sub_forward);

				slon_appendquery(&query1,
						"select %s.subscribeSet_int(%d, %d, %d, '%q'); ",
						rtcfg_namespace,
						sub_set, sub_provider, sub_receiver, sub_forward);
			}
			else if (strcmp(event->ev_type, "ENABLE_SUBSCRIPTION") == 0)
			{
				int		sub_set = (int) strtol(event->ev_data1, NULL, 10);
				int		sub_provider = (int) strtol(event->ev_data2, NULL, 10);
				int		sub_receiver = (int) strtol(event->ev_data3, NULL, 10);

				/*
				 * Do the actual enabling of the set only if
				 * we are the receiver and if we received this
				 * event from the provider.
				 */
				if (sub_receiver == rtcfg_nodeid &&
					sub_provider == node->no_id)
				{
					SlonDString	query2;
					int			sched_rc;
					int			sleeptime = 15;

					rtcfg_enableSubscription(sub_set);
					dstring_init(&query2);
					slon_mkquery(&query2, "rollback transaction");

					while (true)
					{
						/*
						 * Execute the config changes so far, but don't
						 * commit the transaction yet. We have to copy
						 * the data now ...
						 */
						if (query_execute(node, local_dbconn, &query1,
								PGRES_COMMAND_OK) < 0)
							slon_abort();

						/*
						 * If the copy succeeds, exit the loop and let
						 * the transaction commit.
						 */
						if (copy_set(node, local_conn, sub_set) == 0)
						{
							dstring_free(&query2);
							dstring_reset(&query1);
							sched_rc = SCHED_STATUS_OK;
							break;
						}

						/*
						 * Data copy for new enabled set has failed.
						 * Rollback the transaction, sleep and try again.
						 */
						if (query_execute(node, local_dbconn, &query2,
								PGRES_COMMAND_OK) < 0)
							slon_abort();

						slon_log(SLON_WARN, "remoteWorkerThread_%d: "
								"data copy for set %d failed - "
								"sleep %d seconds\n",
								node->no_id, sub_set, sleeptime);
						sched_rc = sched_msleep(node, sleeptime * 1000);
						if (sched_rc != SCHED_STATUS_OK)
							break;

						if (sleeptime < 60)
							sleeptime *= 2;
					}
				}
			}
			else
			{
printf("TODO: ********** remoteWorkerThread: node %d - EVENT %d,%lld %s - unknown event type\n",
node->no_id, event->ev_origin, event->ev_seqno, event->ev_type);
			}

			/*
			 * All simple configuration events fall through here.
			 * Commit the transaction.
			 */
			slon_appendquery(&query1, 
					"commit transaction;");
			if (query_execute(node, local_dbconn, &query1, PGRES_COMMAND_OK) < 0)
				slon_abort();
		}

		free(msg);
	}

	/*
	 * Thread exit time has arrived.
	 */
	slon_log(SLON_DEBUG1,
			"remoteWorkerThread_%d: thread exiting\n",
			node->no_id);

	slon_disconnectdb(local_conn);
	dstring_free(&query1);

	slon_log(SLON_DEBUG1,
			"remoteWorkerThread_%d: thread done\n",
			node->no_id);
	pthread_exit(NULL);
}


/* ----------
 * remoteWorker_event
 *
 *	Used by the remoteListeThread to forward events selected from
 *	the event provider database to the remote nodes worker thread.
 *----------
 */
void
remoteWorker_event(int ev_origin, int64 ev_seqno,
				char *ev_timestamp,
				char *ev_minxid, char *ev_maxxid, char *ev_xip,
				char *ev_type, 
				char *ev_data1, char *ev_data2,
				char *ev_data3, char *ev_data4,
				char *ev_data5, char *ev_data6,
				char *ev_data7, char *ev_data8)
{
	SlonNode   *node;
	struct slon_work_message_event   *msg;
	int			len;
	char	   *cp;
	int			len_timestamp;
	int			len_minxid;
	int			len_maxxid;
	int			len_xip;
	int			len_type;
	int			len_data1 = 0;
	int			len_data2 = 0;
	int			len_data3 = 0;
	int			len_data4 = 0;
	int			len_data5 = 0;
	int			len_data6 = 0;
	int			len_data7 = 0;
	int			len_data8 = 0;

	/*
	 * Stop forwarding events if the replication engine is shutting down
	 */
	if (sched_get_status() != SCHED_STATUS_OK)
	{
		slon_log(SLON_DEBUG2,
				"remoteWorker_event: ignore new events due to shutdown\n");
		return;
	}

	/*
	 * Find the node, make sure it is active and that this event is not
	 * already queued or processed.
	 */
	rtcfg_lock();
	node = rtcfg_findNode(ev_origin);
	if (node == NULL)
	{
		rtcfg_unlock();
		slon_log(SLON_WARN,
				"remoteWorker_event: event %d,%lld ignored - unknown origin\n",
				ev_origin, ev_seqno);
		return;
	}
	if (!node->no_active)
	{
		rtcfg_unlock();
		slon_log(SLON_WARN,
				"remoteWorker_event: event %d,%lld ignored - origin inactive\n",
				ev_origin, ev_seqno);
		return;
	}
	if (node->last_event >= ev_seqno)
	{
		rtcfg_unlock();
		slon_log(SLON_DEBUG2,
				"remoteWorker_event: event %d,%lld ignored - duplicate\n",
				ev_origin, ev_seqno);
		return;
	}

	/*
	 * We lock the worker threads message queue before bumping the
	 * nodes last known event sequence to avoid that another listener
	 * queues a later message before we can insert this one.
	 */
	pthread_mutex_lock(&(node->message_lock));
	node->last_event = ev_seqno;
	rtcfg_unlock();

	/*
	 * Compute the message length and allocate memory. The allocated
	 * memory only needs to be zero-initialized in the structure size.
	 * The following additional space for the event payload data is
	 * overwritten completely anyway.
	 */
	len = offsetof(struct slon_work_message_event, raw_data)
			+ (len_timestamp = strlen(ev_timestamp) + 1)
			+ (len_minxid = strlen(ev_minxid) + 1)
			+ (len_maxxid = strlen(ev_maxxid) + 1)
			+ (len_xip = strlen(ev_xip) + 1)
			+ (len_type = strlen(ev_type) + 1)
			+ ((ev_data1 == NULL) ? 0 : (len_data1 = strlen(ev_data1) + 1))
			+ ((ev_data2 == NULL) ? 0 : (len_data2 = strlen(ev_data2) + 1))
			+ ((ev_data3 == NULL) ? 0 : (len_data3 = strlen(ev_data3) + 1))
			+ ((ev_data4 == NULL) ? 0 : (len_data4 = strlen(ev_data4) + 1))
			+ ((ev_data5 == NULL) ? 0 : (len_data5 = strlen(ev_data5) + 1))
			+ ((ev_data6 == NULL) ? 0 : (len_data6 = strlen(ev_data6) + 1))
			+ ((ev_data7 == NULL) ? 0 : (len_data7 = strlen(ev_data7) + 1))
			+ ((ev_data8 == NULL) ? 0 : (len_data8 = strlen(ev_data8) + 1));
	msg = (struct slon_work_message_event *)malloc(len);
	if (msg == NULL)
	{
		perror("remoteWorker_event: malloc()");
		slon_abort();
	}
	memset(msg, 0, sizeof(struct slon_work_message_event));

	/*
	 * Copy all data into the message.
	 */
	cp = &(msg->raw_data[0]);
	msg->msg_type		= WMSG_EVENT;
	msg->ev_origin		= ev_origin;
	msg->ev_seqno		= ev_seqno;
	msg->ev_timestamp_c = cp; strcpy(cp, ev_timestamp); cp += len_timestamp;
	msg->ev_minxid_c = cp; strcpy(cp, ev_minxid); cp += len_minxid;
	msg->ev_maxxid_c = cp; strcpy(cp, ev_maxxid); cp += len_maxxid;
	msg->ev_xip = cp; strcpy(cp, ev_xip); cp += len_xip;
	msg->ev_type = cp; strcpy(cp, ev_type); cp += len_type;
	if (ev_data1 != NULL)
	{
		msg->ev_data1 = cp; strcpy(cp, ev_data1); cp += len_data1;
	}
	if (ev_data2 != NULL)
	{
		msg->ev_data2 = cp; strcpy(cp, ev_data2); cp += len_data2;
	}
	if (ev_data3 != NULL)
	{
		msg->ev_data3 = cp; strcpy(cp, ev_data3); cp += len_data3;
	}
	if (ev_data4 != NULL)
	{
		msg->ev_data4 = cp; strcpy(cp, ev_data4); cp += len_data4;
	}
	if (ev_data5 != NULL)
	{
		msg->ev_data5 = cp; strcpy(cp, ev_data5); cp += len_data5;
	}
	if (ev_data6 != NULL)
	{
		msg->ev_data6 = cp; strcpy(cp, ev_data6); cp += len_data6;
	}
	if (ev_data7 != NULL)
	{
		msg->ev_data7 = cp; strcpy(cp, ev_data7); cp += len_data7;
	}
	if (ev_data8 != NULL)
	{
		msg->ev_data8 = cp; strcpy(cp, ev_data8); cp += len_data8;
	}

	/*
	 * Add the message to the queue and trigger the condition
	 * variable in case the worker is idle.
	 */
	DLLIST_ADD_TAIL(node->message_head, node->message_tail,
			(struct slon_work_message *)msg);
	pthread_cond_signal(&(node->message_cond));
	pthread_mutex_unlock(&(node->message_lock));
}


/* ----------
 * remoteWorker_wakeup
 *
 *	Send a special WAKEUP message to a worker, causing it to recheck
 *	the runmode and the runtime configuration.
 * ----------
 */
void
remoteWorker_wakeup(int no_id)
{
	SlonNode   *node;
	struct slon_work_message *msg;

	rtcfg_lock();
	node = rtcfg_findNode(no_id);
	if (node == NULL)
	{
		rtcfg_unlock();
		slon_log(SLON_ERROR,
				"remoteWorker_wakeup: unknown node %d\n",
				no_id);
		return;
	}
	if (node->worker_status == SLON_TSTAT_NONE)
	{
		rtcfg_unlock();
		slon_log(SLON_WARN,
				"remoteWorker_wakeup: node %d - no worker thread\n", 
				no_id);
		return;
	}
	rtcfg_unlock();

	msg = (struct slon_work_message *)malloc(sizeof(struct slon_work_message));
	msg->msg_type = WMSG_WAKEUP;

	pthread_mutex_lock(&(node->message_lock));
	DLLIST_ADD_TAIL(node->message_head, node->message_tail, msg);
	pthread_cond_signal(&(node->message_cond));
	pthread_mutex_unlock(&(node->message_lock));
}


/* ----------
 * remoteWorker_confirm
 *
 *	Add a confirm message to the remote worker message queue
 * ----------
 */
void
remoteWorker_confirm(int no_id,
		char *con_origin_c, char *con_received_c,
		char *con_seqno_c, char *con_timestamp_c)
{
	SlonNode   *node;
	struct slon_work_message_confirm *msg;
	struct slon_work_message_confirm *oldmsg;
	int			con_origin;
	int			con_received;
	int64		con_seqno;

	con_origin = strtol(con_origin_c, NULL, 10);
	con_received = strtol(con_received_c, NULL, 10);
	sscanf(con_seqno_c, "%lld", &con_seqno);

	/*
	 * Check that the node exists and that we have a worker thread.
	 */
	rtcfg_lock();
	node = rtcfg_findNode(no_id);
	if (node == NULL)
	{
		rtcfg_unlock();
		slon_log(SLON_ERROR,
				"remoteWorker_confirm: unknown node %d\n",
				no_id);
		return;
	}
	if (node->worker_status == SLON_TSTAT_NONE)
	{
		rtcfg_unlock();
		slon_log(SLON_WARN,
				"remoteWorker_wakeup: node %d - no worker thread\n", 
				no_id);
		return;
	}
	rtcfg_unlock();


	/*
	 * Lock the message queue
	 */
	pthread_mutex_lock(&(node->message_lock));

	/*
	 * Look if we already have a confirm message for this origin+received
	 * node pair.
	 */
	for (oldmsg = (struct slon_work_message_confirm *)(node->message_head);
			oldmsg; oldmsg = (struct slon_work_message_confirm *)(oldmsg->next))
	{
		if (oldmsg->msg_type == WMSG_CONFIRM) {
			if (oldmsg->con_origin == con_origin &&
				oldmsg->con_received == con_received)
			{
				/*
				 * Existing message found. Change it if new seqno is
				 * greater than old. Otherwise just ignore this confirm.
				 */
				if (oldmsg->con_seqno < con_seqno)
				{
					oldmsg->con_seqno = con_seqno;
					strcpy(oldmsg->con_timestamp_c, con_timestamp_c);
				}
				pthread_mutex_unlock(&(node->message_lock));
				return;
			}
		}
	}

	/*
	 * No message found. Create a new one and add it to the queue.
	 */
	msg = (struct slon_work_message_confirm *)
			malloc(sizeof(struct slon_work_message_confirm));
	msg->msg_type = WMSG_CONFIRM;

	msg->con_origin = con_origin;
	msg->con_received = con_received;
	msg->con_seqno = con_seqno;
	strcpy(msg->con_timestamp_c, con_timestamp_c);

	DLLIST_ADD_TAIL(node->message_head, node->message_tail, 
			(struct slon_work_message *)msg);

	/*
	 * Send a condition signal to the worker thread in case it is
	 * waiting for new messages.
	 */
	pthread_cond_signal(&(node->message_cond));
	pthread_mutex_unlock(&(node->message_lock));
}


/* ----------
 * query_execute
 *
 *	Execute a query string that does not return a result set.
 * ----------
 */
static int
query_execute(SlonNode *node, PGconn *dbconn, 
		SlonDString *dsp, int expected_rc)
{
	PGresult   *res;

	res = PQexec(dbconn, dstring_data(dsp));
	if (PQresultStatus(res) != expected_rc)
	{
		slon_log(SLON_ERROR,
				"remoteWorkerThread_%d: \"%s\" %s",
				node->no_id, dstring_data(dsp),
				PQresultErrorMessage(res));
		PQclear(res);
		return -1;
	}
	PQclear(res);
	return 0;
}


/* ----------
 * query_append_event
 *
 *	Add queries to a dstring that notify for Event and Confirm and
 *	that insert a duplicate of an event record as well as the
 *	confirmation for it.
 * ----------
 */
static void
query_append_event(SlonDString *dsp, struct slon_work_message_event *event)
{
	char		seqbuf[64];
	sprintf(seqbuf, "%lld", event->ev_seqno);

	slon_appendquery(dsp,
			"notify \"_%s_Event\"; "
			"notify \"_%s_Confirm\"; "
			"insert into %s.sl_event "
			"    (ev_origin, ev_seqno, ev_timestamp, "
			"     ev_minxid, ev_maxxid, ev_xip, ev_type ",
			rtcfg_cluster_name, rtcfg_cluster_name,
			rtcfg_namespace);
	if (event->ev_data1 != NULL)	dstring_append(dsp, ", ev_data1");
	if (event->ev_data2 != NULL)	dstring_append(dsp, ", ev_data2");
	if (event->ev_data3 != NULL)	dstring_append(dsp, ", ev_data3");
	if (event->ev_data4 != NULL)	dstring_append(dsp, ", ev_data4");
	if (event->ev_data5 != NULL)	dstring_append(dsp, ", ev_data5");
	if (event->ev_data6 != NULL)	dstring_append(dsp, ", ev_data6");
	if (event->ev_data7 != NULL)	dstring_append(dsp, ", ev_data7");
	if (event->ev_data8 != NULL)	dstring_append(dsp, ", ev_data8");
	slon_appendquery(dsp,
			"    ) values ('%d', '%s', '%s', '%s', '%s', '%q', '%s'",
			event->ev_origin, seqbuf, event->ev_timestamp_c,
			event->ev_minxid_c, event->ev_maxxid_c, event->ev_xip,
			event->ev_type);
	if (event->ev_data1 != NULL)
		slon_appendquery(dsp, ", '%q'", event->ev_data1);
	if (event->ev_data2 != NULL)
		slon_appendquery(dsp, ", '%q'", event->ev_data2);
	if (event->ev_data3 != NULL)
		slon_appendquery(dsp, ", '%q'", event->ev_data3);
	if (event->ev_data4 != NULL)
		slon_appendquery(dsp, ", '%q'", event->ev_data4);
	if (event->ev_data5 != NULL)
		slon_appendquery(dsp, ", '%q'", event->ev_data5);
	if (event->ev_data6 != NULL)
		slon_appendquery(dsp, ", '%q'", event->ev_data6);
	if (event->ev_data7 != NULL)
		slon_appendquery(dsp, ", '%q'", event->ev_data7);
	if (event->ev_data8 != NULL)
		slon_appendquery(dsp, ", '%q'", event->ev_data8);
	slon_appendquery(dsp,
			"); "
			"insert into %s.sl_confirm "
			"	(con_origin, con_received, con_seqno, con_timestamp) "
			"   values (%d, %d, '%s', CURRENT_TIMESTAMP); ",
			rtcfg_namespace,
			event->ev_origin, rtcfg_nodeid, seqbuf);
}


/* ----------
 * store_confirm_forward
 *
 *	Call the forwardConfirm() stored procedure.
 * ----------
 */
static void
store_confirm_forward(SlonNode *node, SlonConn *conn,
		struct slon_work_message_confirm *confirm)
{
	SlonDString		query;
	PGresult	   *res;
	char			seqbuf[64];
	struct node_confirm_status *cstat;
	int				cstat_found = false;

	/*
	 * Check the global confirm status if we already know about
	 * this confirmation.
	 */
	pthread_mutex_lock(&node_confirm_lock);
	for (cstat = node_confirm_head; cstat; cstat = cstat->next)
	{
		if (cstat->con_origin == confirm->con_origin &&
			cstat->con_received == confirm->con_received)
		{
			/*
			 * origin+received pair record found.
			 */
			if (cstat->con_seqno >= confirm->con_seqno)
			{
				/*
				 * Confirm status is newer or equal, ignore message.
				 */
				pthread_mutex_unlock(&node_confirm_lock);
				return;
			}
			/*
			 * Set the confirm status to the new seqno and continue
			 * below.
			 */
			cstat_found = true;
			cstat->con_seqno = confirm->con_seqno;
			break;
		}
	}

	/*
	 * If there was no such confirm status entry, add a new one.
	 */
	if (!cstat_found)
	{
		cstat = (struct node_confirm_status *)
				malloc(sizeof (struct node_confirm_status));
		cstat->con_origin = confirm->con_origin;
		cstat->con_received = confirm->con_received;
		cstat->con_seqno = confirm->con_seqno;
		DLLIST_ADD_TAIL(node_confirm_head, node_confirm_tail, cstat);
	}

	pthread_mutex_unlock(&node_confirm_lock);

	/*
	 * Call the stored procedure to forward this status through
	 * the table sl_confirm.
	 */
	dstring_init(&query);
	sprintf(seqbuf, "%lld", confirm->con_seqno);
	
	slon_log(SLON_DEBUG2,
			"remoteWorkerThread_%d: forward confirm %d,%s received by %d\n",
			node->no_id, confirm->con_origin, seqbuf, confirm->con_received);

	slon_mkquery(&query,
			"select %s.forwardConfirm(%d, %d, '%s', '%q'); ",
			rtcfg_namespace,
			confirm->con_origin, confirm->con_received,
			seqbuf,  confirm->con_timestamp_c);

	res = PQexec(conn->dbconn, dstring_data(&query));
	if (PQresultStatus(res) != PGRES_TUPLES_OK)
	{
		slon_log(SLON_ERROR,
				"remoteWorkerThread_%d: \"%s\" %s",
				node->no_id, dstring_data(&query),
				PQresultErrorMessage(res));
		PQclear(res);
		dstring_free(&query);
		return;
	}
	PQclear(res);
	dstring_free(&query);
	return;
}


static int
copy_set(SlonNode *node, SlonConn *local_conn, int set_id)
{
	SlonConn	   *pro_conn;
	PGconn		   *pro_dbconn;
	PGconn		   *loc_dbconn;
	char		   *conninfo;
	char			conn_symname[64];
	SlonDString		query1;
	SlonDString		query2;
	int				ntuples1;
	int				tupno1;
	PGresult	   *res1;
	PGresult	   *res2;
	PGresult	   *res3;
	int				rc;
	char		   *copydata = NULL;
	int				set_origin;
	char		   *ssy_seqno = NULL;
	char		   *ssy_minxid = NULL;
	char		   *ssy_maxxid = NULL;
	char		   *ssy_xip = NULL;
	SlonDString		ssy_action_list;

	slon_log(SLON_DEBUG1, "******* copy_set %d\n", set_id);

	/*
	 * Connect to the provider DB
	 */
	rtcfg_lock();
	conninfo = strdup(node->pa_conninfo);
	rtcfg_unlock();
	sprintf(conn_symname, "copy_set_%d", set_id);
	if ((pro_conn = slon_connectdb(conninfo, conn_symname)) == NULL)
	{
		free(conninfo);
		slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
				"copy set %d - cannot connect to provider DB\n",
				node->no_id, set_id);
		return -1;
	}
	free(conninfo);
	slon_log(SLON_DEBUG2, "remoteWorkerThread_%d: "
			"connected to provider DB\n",
			node->no_id);

	pro_dbconn = pro_conn->dbconn;
	loc_dbconn = local_conn->dbconn;
	dstring_init(&query1);

	/*
	 * Begin a serialized transaction and select the list of all
	 * tables the provider currently has in the set.
	 */
	slon_mkquery(&query1,
			"start transaction; "
			"set transaction isolation level serializable; "
			"select T.tab_id, "
			"    \"pg_catalog\".quote_ident(PGN.nspname) || '.' || "
			"    \"pg_catalog\".quote_ident(PGC.relname) as tab_fqname, "
			"    T.tab_attkind, T.tab_comment "
			"from %s.sl_table T, "
			"    \"pg_catalog\".pg_class PGC, "
			"    \"pg_catalog\".pg_namespace PGN "
			"where T.tab_set = %d "
			"    and T.tab_reloid = PGC.oid "
			"    and PGC.relnamespace = PGN.oid "
			"order by tab_id; ",
			rtcfg_namespace, set_id);
	res1 = PQexec(pro_dbconn, dstring_data(&query1));
	if (PQresultStatus(res1) != PGRES_TUPLES_OK)
	{
		slon_log(SLON_ERROR, "remoteWorkerThread_%d: \"%s\" %s",
				node->no_id, dstring_data(&query1),
				PQresultErrorMessage(res1));
		PQclear(res1);
		slon_disconnectdb(pro_conn);
		dstring_free(&query1);
		return -1;
	}
	ntuples1 = PQntuples(res1);

	/*
	 * For each table in the set
	 */
	for (tupno1 = 0; tupno1 < ntuples1; tupno1++)
	{
		int		tab_id		= strtol(PQgetvalue(res1, tupno1, 0), NULL, 10);
		char   *tab_fqname	= PQgetvalue(res1, tupno1, 1);
		char   *tab_attkind	= PQgetvalue(res1, tupno1, 2);
		char   *tab_comment	= PQgetvalue(res1, tupno1, 3);
		int64	copysize	= 0;

		slon_log(SLON_DEBUG2, "remoteWorkerThread_%d: "
				"tab_id=%d tab_fqname=%s tab_attkind=%s tab_comment='%s'\n",
				node->no_id,
				tab_id, tab_fqname, tab_attkind, tab_comment);

		/*
		 * Call the setAddTable_int() stored procedure. Up to now, while
		 * we have not been subscribed to the set, this should have been
		 * suppressed.
		 */
		slon_mkquery(&query1,
				"select %s.setAddTable_int(%d, %d, '%q', '%q', '%q'); ",
				rtcfg_namespace,
				set_id, tab_id, tab_fqname, tab_attkind, tab_comment);
		if (query_execute(node, loc_dbconn, &query1, PGRES_TUPLES_OK) < 0)
		{
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}

		/*
		 * Begin a COPY from stdin for the table on the local DB
		 */
		slon_mkquery(&query1, "copy %s from stdin; ", tab_fqname);
		res2 = PQexec(loc_dbconn, dstring_data(&query1));
		if (PQresultStatus(res2) != PGRES_COPY_IN)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: \"%s\" %s %s\n",
					node->no_id, dstring_data(&query1),
					PQresultErrorMessage(res2),
					PQerrorMessage(loc_dbconn));
			PQclear(res2);
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}

		/*
		 * Begin a COPY to stdout for the table on the provider DB
		 */
		slon_mkquery(&query1, "copy %s to stdout; ", tab_fqname);
		res3 = PQexec(pro_dbconn, dstring_data(&query1));
		if (PQresultStatus(res3) != PGRES_COPY_OUT)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: \"%s\" %s %s\n",
					node->no_id, dstring_data(&query1),
					PQresultErrorMessage(res2),
					PQerrorMessage(pro_dbconn));
			PQputCopyEnd(loc_dbconn, "Slony-I: copy set operation failed");
			PQclear(res3);
			PQclear(res2);
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}

		/*
		 * Copy the data over
		 */
		while ((rc = PQgetCopyData(pro_dbconn, &copydata, 0)) > 0)
		{
			int		len = strlen(copydata);

			copysize += (int64)len;

			if (PQputCopyData(loc_dbconn, copydata, len) != 1)
			{
				slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
						"PQputCopyData() - %s",
						node->no_id, PQerrorMessage(loc_dbconn));
				PQfreemem(copydata);
				PQputCopyEnd(loc_dbconn, "Slony-I: copy set operation failed");
				PQclear(res3);
				PQclear(res2);
				PQclear(res1);
				slon_disconnectdb(pro_conn);
				dstring_free(&query1);
				return -1;
			}
			PQfreemem(copydata);
		}
		if (rc != -1)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
					"PGgetCopyData() %s",
					node->no_id, PQerrorMessage(pro_dbconn)); 
			PQputCopyEnd(loc_dbconn, "Slony-I: copy set operation failed");
			PQclear(res3);
			PQclear(res2);
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}

		/*
		 * Check that the COPY to stdout on the provider node
		 * finished successful.
		 */
		res3 = PQgetResult(pro_dbconn);
		if (PQresultStatus(res3) != PGRES_COMMAND_OK)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
					"copy to stdout on provider - %s %s",
					node->no_id, PQresStatus(PQresultStatus(res3)),
					PQresultErrorMessage(res3));
			PQputCopyEnd(loc_dbconn, "Slony-I: copy set operation failed");
			PQclear(res3);
			PQclear(res2);
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}
		PQclear(res3);

		/*
		 * End the COPY from stdin on the local node with success
		 */
		if (PQputCopyEnd(loc_dbconn, NULL) != 1)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
					"PGputCopyEnd() %s",
					node->no_id, PQerrorMessage(loc_dbconn)); 
			PQclear(res2);
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}
		res2 = PQgetResult(loc_dbconn);
		if (PQresultStatus(res2) != PGRES_COMMAND_OK)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
					"copy from stdin on local node - %s %s",
					node->no_id, PQresStatus(PQresultStatus(res2)),
					PQresultErrorMessage(res2));
			PQclear(res2);
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}
		PQclear(res2);

		slon_log(SLON_DEBUG2, "remoteWorkerThread_%d: "
				"%lld bytes copied for table %s\n",
				node->no_id, copysize, tab_fqname);
	}
	PQclear(res1);

	/*
	 * Determine the set origin
	 */
	slon_mkquery(&query1,
			"select set_origin from %s.sl_set where set_id = %d; ",
			rtcfg_namespace, set_id);
	res1 = PQexec(pro_dbconn, dstring_data(&query1));
	if (PQresultStatus(res1) != PGRES_TUPLES_OK)
	{
		slon_log(SLON_ERROR, "remoteWorkerThread_%d: \"%s\" %s",
				node->no_id, dstring_data(&query1),
				PQresultErrorMessage(res1));
		PQclear(res1);
		slon_disconnectdb(pro_conn);
		dstring_free(&query1);
		return -1;
	}
	if (PQntuples(res1) != 1)
	{
		slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
				"cannot determine origin of set %d\n",
				node->no_id, set_id);
		PQclear(res1);
		slon_disconnectdb(pro_conn);
		dstring_free(&query1);
		return -1;
	}
	set_origin = strtol(PQgetvalue(res1, 0, 0), NULL, 10);
	PQclear(res1);

	/*
	 * It depends on who is our data provider how we construct
	 * the initial setsync status.
	 */
	if (set_origin == node->no_id)
	{
		/*
		 * Our provider is the origin, so we have to construct
		 * the setsync from scratch. Let's see if there is any
		 * SYNC event known.
		 */
		slon_mkquery(&query1,
				"select max(ev_seqno) as ssy_seqno "
				"from %s.sl_event "
				"where ev_origin = %d and ev_type = 'SYNC'; ",
				rtcfg_namespace, node->no_id);
		res1 = PQexec(pro_dbconn, dstring_data(&query1));
		if (PQresultStatus(res1) != PGRES_TUPLES_OK)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: \"%s\" %s",
					node->no_id, dstring_data(&query1),
					PQresultErrorMessage(res1));
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}
		if (PQntuples(res1) != 1)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
					"query \"%s\" did not return a result\n",
					node->no_id, dstring_data(&query1));
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}
		if (PQgetisnull(res1, 0, 0))
		{
			/*
			 * No SYNC event found, so we initialize the setsync to
			 * zeroes with ALL action sequences that exist.
			 */
			ssy_seqno	= "0";
			ssy_minxid	= "0";
			ssy_maxxid	= "0";
			ssy_xip		= "";

			slon_mkquery(&query1,
					"select log_actionseq "
					"from %s.sl_log_1 where log_origin = %d "
					"union select log_actionseq "
					"from %s.sl_log_2 where log_origin = %d; ",
					rtcfg_namespace, node->no_id,
					rtcfg_namespace, node->no_id);
		}
		else
		{
			/*
			 * Use the last SYNC's snapshot information and
			 * set the action sequence list to all actions after that.
			 */
			slon_mkquery(&query1,
					"select ev_seqno, ev_minxid, ev_maxxid, ev_xip "
					"from %s.sl_event where ev_seqno = '%s'; ",
					rtcfg_namespace, PQgetvalue(res1, 0, 0));
			PQclear(res1);
			res1 = PQexec(pro_dbconn, dstring_data(&query1));
			if (PQresultStatus(res1) != PGRES_TUPLES_OK)
			{
				slon_log(SLON_ERROR, "remoteWorkerThread_%d: \"%s\" %s",
						node->no_id, dstring_data(&query1),
						PQresultErrorMessage(res1));
				PQclear(res1);
				slon_disconnectdb(pro_conn);
				dstring_free(&query1);
				return -1;
			}
			if (PQntuples(res1) != 1)
			{
				slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
						"query \"%s\" did not return a result\n",
						node->no_id, dstring_data(&query1));
				PQclear(res1);
				slon_disconnectdb(pro_conn);
				dstring_free(&query1);
				return -1;
			}

			ssy_seqno	= PQgetvalue(res1, 0, 0);
			ssy_minxid	= PQgetvalue(res1, 0, 1);
			ssy_maxxid	= PQgetvalue(res1, 0, 2);
			ssy_xip		= PQgetvalue(res1, 0, 3);

			dstring_init(&query2);
			slon_mkquery(&query2,
					"log_xid > '%s' or (log_xid >= '%s'",
					ssy_maxxid, ssy_minxid);
			if (strlen(ssy_xip) != 0)
				slon_appendquery(&query2, " and log_xid in (%s))", ssy_xip);
			else
				slon_appendquery(&query2, ")");
			
			slon_mkquery(&query1,
					"select log_actionseq "
					"from %s.sl_log_1 where log_origin = %d and %s "
					"union select log_actionseq "
					"from %s.sl_log_2 where log_origin = %d and %s; ",
					rtcfg_namespace, node->no_id, dstring_data(&query2),
					rtcfg_namespace, node->no_id, dstring_data(&query2));
			dstring_free(&query2);
		}

		/*
		 * query1 now contains the selection for the ssy_action_list
		 * selection from both log tables. Fill the dstring.
		 */
		res2 = PQexec(pro_dbconn, dstring_data(&query1));
		if (PQresultStatus(res2) != PGRES_TUPLES_OK)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: \"%s\" %s",
					node->no_id, dstring_data(&query1),
					PQresultErrorMessage(res2));
			PQclear(res2);
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}
		ntuples1 = PQntuples(res2);
		dstring_init(&ssy_action_list);
		if (ntuples1 > 0)
		{
			dstring_addchar(&ssy_action_list, '\'');
			dstring_append(&ssy_action_list, PQgetvalue(res2, 0, 0));
			dstring_addchar(&ssy_action_list, '\'');
		}
		for (tupno1 = 1; tupno1 < ntuples1; tupno1++)
		{
			dstring_addchar(&ssy_action_list, ',');
			dstring_addchar(&ssy_action_list, '\'');
			dstring_append(&ssy_action_list, PQgetvalue(res2, 0, 0));
			dstring_addchar(&ssy_action_list, '\'');
		}
		dstring_terminate(&ssy_action_list);
		PQclear(res2);
	}
	else
	{
		/*
		 * Our provider is another slave, so we can copy the
		 * existing setsync from him.
		 */
		slon_mkquery(&query1,
				"select ssy_seqno, ssy_minxid, ssy_maxxid, "
				"    ssy_xip, ssy_action_list "
				"from %s.sl_setsync where ssy_setid = %d; ",
				rtcfg_namespace, set_id);
		res1 = PQexec(pro_dbconn, dstring_data(&query1));
		if (PQresultStatus(res1) != PGRES_TUPLES_OK)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: \"%s\" %s",
					node->no_id, dstring_data(&query1),
					PQresultErrorMessage(res1));
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}
		if (PQntuples(res1) != 1)
		{
			slon_log(SLON_ERROR, "remoteWorkerThread_%d: "
					"sl_setsync entry for set %d not found on provider\n",
					node->no_id, set_id);
			PQclear(res1);
			slon_disconnectdb(pro_conn);
			dstring_free(&query1);
			return -1;
		}

		dstring_init(&ssy_action_list);
		ssy_seqno	= PQgetvalue(res1, 0, 0);
		ssy_minxid	= PQgetvalue(res1, 0, 1);
		ssy_maxxid	= PQgetvalue(res1, 0, 2);
		ssy_xip		= PQgetvalue(res1, 0, 3);
		dstring_append(&ssy_action_list, PQgetvalue(res1, 0, 4));
		dstring_terminate(&ssy_action_list);
	}

	/*
	 * Create our own initial setsync entry
	 */
	slon_mkquery(&query1,
			"insert into %s.sl_setsync "
			"    (ssy_setid, ssy_origin, ssy_seqno, "
			"     ssy_minxid, ssy_maxxid, ssy_xip, ssy_action_list) "
			"    values ('%d', '%d', '%s', '%s', '%s', '%q', '%q'); ",
			rtcfg_namespace,
			set_id, node->no_id, ssy_seqno, ssy_minxid, ssy_maxxid, ssy_xip,
			dstring_data(&ssy_action_list));
	PQclear(res1);
	dstring_free(&ssy_action_list);
	if (query_execute(node, loc_dbconn, &query1, PGRES_COMMAND_OK) < 0)
	{
		slon_disconnectdb(pro_conn);
		dstring_free(&query1);
		return -1;
	}

	/*
	 * Roll back the transaction we used on the provider and close
	 * the database connection.
	 */
	slon_mkquery(&query1, "rollback transaction");
	if (query_execute(node, pro_dbconn, &query1, PGRES_COMMAND_OK) < 0)
	{
		slon_disconnectdb(pro_conn);
		dstring_free(&query1);
		return -1;
	}
	slon_disconnectdb(pro_conn);
	dstring_free(&query1);

	return 0;
}


