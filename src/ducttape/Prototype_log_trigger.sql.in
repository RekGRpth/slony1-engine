-- ----------------------------------------------------------------------
-- FUNCTION setSessionRole(role)
--
--    Prototype in PL/Tcl - final version needs to be in C
-- ----------------------------------------------------------------------
create function @NAMESPACE@.setSessionRole(text)
returns text
as '
	upvar #0	@CLUSTERNAME@_global_data	gbl

	if {[info exists gbl(session_role)] && "$gbl(session_role)" != "$1"} {
		elog ERROR "cannot change session_role once set"
	}

	set gbl(session_role) $1
	return $1
' language pltcl;


-- ----------------------------------------------------------------------
-- FUNCTION getSessionRole()
--
--    Prototype in PL/Tcl - final version needs to be in C
-- ----------------------------------------------------------------------
create function @NAMESPACE@.getSessionRole()
returns text
as '
	upvar #0	@CLUSTERNAME@_global_data	gbl

	if {![info exists gbl(session_role)]} {
		elog ERROR "session_role not set"
	}

	return $gbl(session_role)
' language pltcl;


-- ----------------------------------------------------------------------
-- TRIGGER PROCEDURE logTrigger
--
--    Prototype in PL/Tcl - final version needs to be in C
-- ----------------------------------------------------------------------
create function @NAMESPACE@.logTrigger () returns trigger
AS '
	upvar #0	@CLUSTERNAME@_global_data	gbl

	set namespace $1
	set table_id $2
	set attkind $3

	regsub "^\\"?_(\\[^\\"\\]*)\\"?\\$" $namespace "\\\\1" clustername

	#
	# On first call initialize global data and create prepared
	# plans for all database operations.
	#
	if {![info exists gbl]} {
		set gbl(current_xid)		invalid
		set gbl(session_role)		normal

		spi_exec "select $namespace.getLocalNodeId(''_$clustername'') as server_id"
		set gbl(server_id) $server_id

		#
		# Plan to call getCurrentXid()
		#
		set gbl(p_getxid) [spi_prepare \\
			"select $namespace.getCurrentXid() as current_xid" \\
				{}]

		#
		# Plan to insert rows into the log
		#
		set gbl(p_log) [spi_prepare \\
				"insert into $namespace.sl_log_1
					(log_origin, log_xid, log_tableid, log_actionseq,
						log_cmdtype, log_cmddata)
					values (''$gbl(server_id)'', \\$1, \\$2,
						nextval(''$namespace.sl_action_seq''),
						\\$3, \\$4);" \\
					[list "$namespace.xxid" int4 char text]]
		#
		# proc quote_ident()
		#
		proc quote_ident {str} {
			if {[regexp "^\\[_a-z\\]\\[_a-z0-9\\]*\\$" $str]} {
				return $str
			}

			regsub -all {"} $str {""} str
			return "\\"$str\\""
		}

		#
		# proc quote_literal
		#
		proc quote_literal {str} {
			regsub -all {''} $str {''''} str
			return "''$str''"
		}
	} else {
		#
		# Suppress the trigger in replicate session role
		#
		if {"$gbl(session_role)" == "slon"} {
			return OK
		}
	}

	#
	# Get the current transaction ID.
	#
	spi_execp $gbl(p_getxid)

	#
	# Collect information about the action depending on the
	# query type.
	#
	switch -- $TG_op {
		INSERT {
			#
			# On INSERT the logged command_sql is the entire
			# insert statement after the table name. 
			#
			set l_attname {}
			set l_attval  {}

			foreach att [lrange $TG_relatts 1 end] kind [split $attkind {}] {
				lappend l_attname [quote_ident $att]
				if {[info exists NEW($att)]} {
					lappend l_attval [quote_literal $NEW($att)]
				} else {
					if {"$kind" == "B"} {
						elog ERROR "Slony-I: attribute $att is of kind Balance - NULL value not supported"
					}
					lappend l_attval NULL
				}
			}

			set command_type I
			set command_sql "([join $l_attname ,]) VALUES ([join $l_attval ,])"
		}
		UPDATE {
			#
			# On UPDATE the logged command_sql is everything
			# after the SET keyword including the WHERE clause.
			#
			set l_assign {}
			set l_qual   {}

			foreach att [lrange $TG_relatts 1 end] kind [split $attkind {}] {
				if {[info exists OLD($att)]} {
					if {[info exists NEW($att)]} {
						if {[string compare $OLD($att) $NEW($att)] != 0} {
							if {"$kind" == "b"} {
								lappend l_assign "[quote_ident $att]=[quote_ident $att]+[quote_literal $NEW($att)]-[quote_literal $OLD($att)]"
							} else {
								lappend l_assign "[quote_ident $att]=[quote_literal $NEW($att)]"
							}
						}
					} else {
						if {"$kind" == "b"} {
							elog ERROR "Slony-I: attribute $att is of kind Balance - NULL value not supported"
						}
						lappend l_assign "[quote_ident $att]=NULL"
					}
				} else {
					if {[info exists NEW($att)]} {
						lappend l_assign "[quote_ident $att]=[quote_literal $NEW($att)]"
					}
				}
				if {"$kind" == "k"} {
					lappend l_qual "[quote_ident $att]=[quote_literal $OLD($att)]"
					if {![info exists first_keyatt]} {
						set first_keyatt $att
					}
				}
			}

			#
			# In the case that ALL new values are identical to the old ones,
			# we fake an update on the first key attribute.
			#
			if {[llength $l_assign] == 0} {
				lappend l_assign "[quote_ident $first_keyatt]=[quote_literal $NEW($first_keyatt)]"
			}

			set command_type U
			set command_sql "[join $l_assign ,] WHERE [join $l_qual { AND }]"
		}
		DELETE {
			#
			# On DELETE we need only the WHERE clause without even
			# that keyword.
			#
			set l_qual   {}

			foreach att [lrange $TG_relatts 1 end] kind [split $attkind {}] {
				if {"$kind" == "k"} {
					lappend l_qual "[quote_ident $att]=[quote_literal $OLD($att)]"
				}
			}

			set command_type D
			set command_sql "[join $l_qual { AND }]"
		}
		default {
			elog ERROR "Slony-I: unknown operation type $TG_op"
		}
	}

	#
	# Now use spi_execp to insert a new log row.
	#
	spi_execp $gbl(p_log) \\
		[list $current_xid $table_id $command_type $command_sql]

	return OK
' language pltcl
	security definer;


